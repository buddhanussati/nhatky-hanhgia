 
		const DHAMMAPADA = [
    {t:"\"Intention shapes experiences;<br> intention is first, they’re made by intention.<br> If with corrupt intent<br> you speak or act,<br> suffering follows you,<br> like a wheel, the ox’s foot.\""},
 {t:"\"Intention shapes experiences;<br> intention is first, they’re made by intention.<br> If with pure intent<br> you speak or act,<br> happiness follows you<br> like a shadow that never leaves.\""},
 {t:"\"“They abused me, they hit me!<br> They beat me, they robbed me!”<br> For those who bear such a grudge,<br> hatred is never laid to rest.\""},
 {t:"\"“They abused me, they hit me!<br> They beat me, they robbed me!”<br> For those who bear no such grudge,<br> hatred is laid to rest.\""},
 {t:"\"For never is hatred<br> laid to rest by hate,<br> it’s laid to rest by love:<br> this is an ancient teaching.\""},
 {t:"\"When others do not understand,<br> let us, who do understand this,<br> restrain ourselves in this regard;<br> for that is how conflicts are laid to rest.\""},
 {t:"\"Those who contemplate the beautiful,<br> their faculties unrestrained,<br> immoderate in eating,<br> lazy, lacking energy:<br> Māra strikes them down<br> like the wind, a feeble tree.\""},
 {t:"\"Those who contemplate the ugly,<br> their faculties well-restrained,<br> eating in moderation,<br> faithful and energetic:<br> Māra cannot strike them down,<br> like the wind, a rocky mountain.\""},
 {t:"\"One who, not free of stains themselves,<br> would wear the robe stained in ocher,<br> bereft of self-control and of truth:<br> they are not worthy of the ocher robe.\""},
 {t:"\"One who’s purged all their stains,<br> steady in ethics,<br> possessed of self-control and of truth,<br> they are truly worthy of the ocher robe.\""},
 {t:"\"Thinking the inessential is essential,<br> seeing the essential as inessential;<br> they don’t realize the essential,<br> for wrong thoughts are their habitat.\""},
 {t:"\"Having known the essential as essential,<br> and the inessential as inessential;<br> they realize the essential,<br> for right thoughts are their habitat.\""},
 {t:"\"Just as rain seeps into<br> a poorly roofed house,<br> lust seeps into<br> an undeveloped mind.\""},
 {t:"\"Just as rain doesn’t seep into<br> a well roofed house,<br> lust doesn’t seep into<br> a well developed mind.\""},
 {t:"\"Here they grieve, hereafter they grieve,<br> an evildoer grieves in both places.<br> They grieve and fret,<br> seeing their own corrupt deeds.\""},
 {t:"\"Here they rejoice, hereafter they rejoice,<br> one who does good rejoices in both places.<br> They rejoice and celebrate,<br> seeing their own pure deeds.\""},
 {t:"\"Here they’re tormented,<br> hereafter they’re tormented,<br> an evildoer is tormented in both places.<br> They’re tormented<br> thinking of bad things they’ve done;<br> when gone to a bad place,<br> they’re tormented all the more.\""},
 {t:"\"Here they delight, hereafter they delight,<br> one who does good delights in both places.<br> They delight thinking of good things they’ve done;<br> when gone to a good place, they delight all the more.\""},
 {t:"\"Much though they may recite scripture,<br> if a negligent person does not apply them,<br> then, like a cowherd who counts the cattle of others,<br> they miss out on the blessings of the ascetic life.\""},
 {t:"\"Little though they may recite scripture,<br> if they live in line with the teaching,<br> having given up greed, hate, and delusion,<br> with deep understanding and heart well freed,<br> not grasping to this life or the next,<br> they share in the blessings of the ascetic life.\""},
 {t:"\"Heedfulness is the state free of death;<br> heedlessness is the state of death.<br> The heedful do not die,<br> while the heedless are like the dead.\""},
 {t:"\"Understanding this distinction<br> when it comes to heedfulness,<br> the astute rejoice in heedfulness,<br> happy in the noble ones’ domain.\""},
 {t:"\"They who regularly meditate,<br> always staunchly vigorous;<br> the attentive realize extinguishment,<br> the supreme sanctuary from the yoke.\""},
 {t:"\"For the hard-working and mindful,<br> pure of deed and attentive,<br> restrained, living righteously, and diligent,<br> their reputation only grows.\""},
 {t:"\"By hard work and diligence,<br> by restraint and by self-control,<br> a smart person would build an island<br> that the floods cannot overflow.\""},
 {t:"\"Fools and simpletons<br> devote themselves to negligence.<br> But the wise protect diligence<br> as their best treasure.\""},
 {t:"\"Don’t devote yourself to negligence,<br> or delight in erotic intimacy.<br> For if you’re diligent and meditate,<br> you’ll attain abundant happiness.\""},
 {t:"\"When the astute dispel negligence<br> by means of diligence,<br> ascending the palace of wisdom,<br> sorrowless, they behold this generation of sorrow,<br> as an attentive one on a mountain top<br> beholds the fools below.\""},
 {t:"\"Heedful among the heedless,<br> wide awake while others sleep—<br> a true sage leaves them behind,<br> like a swift horse passing a feeble.\""},
 {t:"\"Maghavā became chief of the gods<br> by means of diligence.<br> People praise diligence,<br> while negligence is always deplored.\""},
 {t:"\"A mendicant who loves to be diligent,<br> seeing fear in negligence—<br> advances like fire,<br> burning up fetters big and small.\""},
 {t:"\"A mendicant who loves to be diligent,<br> seeing fear in negligence—<br> such a one can’t decline,<br> and has drawn near to extinguishment.\""},
 {t:"\"The mind quivers and shakes,<br> hard to guard, hard to curb.<br> The discerning straighten it out,<br> like a fletcher straightens an arrow.\""},
 {t:"\"Like a fish pulled from the sea<br> and cast upon the shore,<br> this mind flounders about,<br> trying to throw off Māra’s dominion.\""},
 {t:"\"Hard to hold back, flighty,<br> alighting where it will;<br> it’s good to tame the mind;<br> a tamed mind leads to bliss.\""},
 {t:"\"So hard to see, so subtle,<br> alighting where it will;<br> the discerning protect the mind,<br> a guarded mind leads to bliss.\""},
 {t:"\"The mind travels far, wandering alone;<br> incorporeal, it lies hidden in the heart.<br> Those who will restrain the mind<br> are freed from Māra’s bonds.\""},
 {t:"\"Those of unsteady mind,<br> who don’t understand the true teaching,<br> and whose confidence wavers,<br> do not perfect their wisdom.\""},
 {t:"\"One whose mind is not festering,<br> whose heart is undamaged,<br> who’s given up right and wrong,<br> alert, has nothing to fear.\""},
 {t:"\"Knowing this body breaks like a pot,<br> and fortifying the mind like a citadel,<br> attack Māra with the sword of wisdom,<br> guard your conquest, and never settle.\""},
 {t:"\"All too soon this body<br> will lie upon the earth,<br> bereft of consciousness,<br> tossed aside like a worthless log.\""},
 {t:"\"A wrongly directed mind<br> would do you more harm<br> than a hater to the hated,<br> or an enemy to their foe.\""},
 {t:"\"A rightly directed mind<br> would do you more good<br> than your mother or father<br> or any other relative.\""},
 {t:"\"Who bestirs this earth,<br> and the Yama realm with its gods?<br> Who sets out the well-taught word of truth,<br> as an expert a flower?\""},
 {t:"\"A trainee bestirs this earth,<br> and the Yama realm with its gods.<br> A trainee sets out the well-taught word of truth,<br> as an expert a flower.\""},
 {t:"\"Knowing this body’s like foam,<br> realizing it’s all just a mirage,<br> and cutting off Māra’s blossoming,<br> vanish from the King of Death.\""},
 {t:"\"As a mighty flood sweeps off a sleeping village,<br> death steals away a man<br> even as he gathers flowers,<br> his mind caught up in them.\""},
 {t:"\"The terminator gains control of the man<br> who has not had his fill of pleasures,<br> even as he gathers flowers,<br> his mind caught up in them.\""},
 {t:"\"A bee takes the nectar<br> and moves on, doing no damage<br> to the flower’s beauty and fragrance;<br> and that’s how a sage should walk in the village.\""},
 {t:"\"Don’t find fault with others,<br> with what they’ve done or left undone.<br> You should only watch yourself,<br> what you’ve done or left undone.\""},
 {t:"\"Just like a glorious flower<br> that’s colorful but lacks fragrance;<br> eloquent speech is fruitless<br> for one who does not act on it.\""},
 {t:"\"Just like a glorious flower<br> that’s both colorful and fragrant,<br> eloquent speech is fruitful<br> for one who acts on it.\""},
 {t:"\"Just as one would create many garlands<br> from a heap of flowers,<br> when a person has come to be born,<br> they should do many skillful things.\""},
 {t:"\"The fragrance of flowers doesn’t spread upwind,<br> nor sandalwood, pinwheel, or jasmine;<br> but the fragrance of the good spreads upwind;<br> a true person’s virtue spreads in every direction.\""},
 {t:"\"Among all the fragrances—<br> sandalwood or pinwheel<br> or lotus or jasmine—<br> the fragrance of virtue is supreme.\""},
 {t:"\"Faint is the fragrance<br> of sandal or pinwheel;<br> but the fragrance of the virtuous<br> floats to the highest gods.\""},
 {t:"\"For those accomplished in ethics,<br> meditating diligently,<br> freed through the highest knowledge,<br> Māra cannot find their path.\""},
 {t:"\"From a heap of trash<br> discarded on the highway,<br> a lotus might blossom,<br> fragrant and delightful.\""},
 {t:"\"So too, among those thought of as trash,<br> a disciple of the perfect Buddha<br> outshines with their wisdom<br> the blind ordinary folk.\""},
 {t:"\"Long is the night for the wakeful;<br> long is the league for the weary;<br> long transmigrate the fools<br> who don’t understand the true teaching.\""},
 {t:"\"If while wandering you find no partner<br> equal or better than yourself,<br> then firmly resolve to wander alone—<br> there’s no fellowship with fools.\""},
 {t:"\"“Sons are mine, wealth is mine”—<br> thus the fool frets.<br> For even your self is not your own,<br> let alone your sons or wealth.\""},
 {t:"\"The fool who thinks they’re a fool<br> is wise at least to that extent.<br> But the true fool is said to be one<br> who imagines that they are wise.\""},
 {t:"\"Though a fool attends to the wise<br> even for the rest of their life,<br> they still don’t understand the teaching,<br> like a spoon the taste of the soup.\""},
 {t:"\"If a clever person attends to the wise<br> even just for an hour or so,<br> they swiftly understand the teaching,<br> like a tongue the taste of the soup.\""},
 {t:"\"Fools and simpletons behave<br> like their own worst enemies,<br> doing wicked deeds<br> that ripen as bitter fruit.\""},
 {t:"\"It’s not good to do a deed<br> that plagues you later on,<br> for which you weep and wail,<br> as its effect stays with you.\""},
 {t:"\"It is good to do a deed<br> that doesn’t plague you later on,<br> that gladdens and cheers,<br> as its effect stays with you.\""},
 {t:"\"The fool imagines that evil is sweet,<br> so long as it has not yet ripened.<br> But as soon as that evil ripens,<br> they fall into suffering.\""},
 {t:"\"Month after month a fool may eat<br> food from a grass-blade’s tip;<br> but they’ll never be worth a sixteenth part<br> of one who has appraised the teaching.\""},
 {t:"\"For a wicked deed that has been done<br> does not curdle quickly like milk.<br> Smoldering, it follows the fool,<br> like a fire smothered over with ash.\""},
 {t:"\"Whatever fame a fool may get,<br> it only gives rise to harm.<br> Whatever good features they have it ruins,<br> and blows their head into bits.\""},
 {t:"\"They’d seek the esteem that they lack,<br> and status among the mendicants;<br> authority over monasteries,<br> and honor among other families.\""},
 {t:"\"“Let both layfolk and renunciants think<br> the work was done by me alone.<br> In anything at all that’s to be done,<br> let them fall under my sway alone.”<br> So thinks the fool,<br> their greed and pride only growing.\""},
 {t:"\"For the means to profit and the path to quenching<br> are two quite different things.<br> A mendicant disciple of the Buddha,<br> understanding what this really means,<br> would never delight in honors,<br> but rather would foster seclusion.\""},
 {t:"\"Regard one who sees your faults<br> as a guide to a hidden treasure.<br> Stay close to one so wise and astute<br> who corrects you when you need it.<br> Sticking close to such an impartial person,<br> things get better, not worse.\""},
 {t:"\"Advise and instruct;<br> curb wickedness:<br> for you shall be loved by the good,<br> and disliked by the bad.\""},
 {t:"\"Don’t mix with bad friends,<br> nor with the worst of men.<br> Mix with spiritual friends,<br> and with the best of men.\""},
 {t:"\"Through joy in the teaching you sleep at ease,<br> with clear and confident heart.<br> An astute person always delights in the teaching<br> proclaimed by the Noble One.\""},
 {t:"\"Irrigators guide water,<br> fletchers straighten arrows,<br> carpenters carve timber,<br> the astute tame themselves.\""},
 {t:"\"As the wind cannot stir<br> a solid mass of rock,<br> so too blame and praise<br> do not affect the wise.\""},
 {t:"\"Like a deep lake,<br> clear and unclouded,<br> so clear are the astute<br> when they hear the teachings.\""},
 {t:"\"True persons give up everything,<br> they don’t cajole for the things they desire.<br> Though touched by sadness or happiness,<br> the astute appear neither depressed nor elated.\""},
 {t:"\"Never wish for success by unjust means,<br> for your own sake or that of another,<br> desiring children, wealth, or nation;<br> rather, be virtuous, wise, and just.\""},
 {t:"\"Few are those among humans<br> who cross to the far shore.<br> The rest just run around<br> on the near shore.\""},
 {t:"\"When the teaching is well explained,<br> those who practice accordingly<br> will cross over<br> Death’s dominion so hard to pass.\""},
 {t:"\"Rid of dark qualities,<br> an astute person should develop the bright.<br> Leaving home behind<br> for the seclusion so hard to enjoy,\""},
 {t:"\"try to find satisfaction there,<br> having left behind sensual pleasures.<br> Owning nothing, an astute person<br> would cleanse themselves of mental corruptions.\""},
 {t:"\"Those whose minds are rightly developed<br> in the awakening factors;<br> who, letting go of attachments,<br> delight in not grasping:<br> with defilements ended, brilliant,<br> they are quenched in this world.\""},
 {t:"\"At journey’s end, rid of sorrow;<br> everywhere free,<br> all ties given up,<br> no fever is found in them.\""},
 {t:"\"The mindful apply themselves;<br> they delight in no abode.<br> Like a swan gone from the marsh,<br> they leave home after home behind.\""},
 {t:"\"Those with nothing stored up,<br> who have understood their food,<br> whose domain is the liberation<br> of the signless and the empty:<br> their path is hard to trace,<br> like birds in the sky.\""},
 {t:"\"One whose defilements have ended;<br> who’s not attached to food;<br> whose domain is the liberation<br> of the signless and the empty:<br> their track is hard to trace,<br> like birds in the sky.\""},
 {t:"\"Whose faculties have become serene,<br> like horses tamed by a charioteer,<br> who has abandoned conceit and defilements;<br> the unaffected one is envied by even the gods.\""},
 {t:"\"Undisturbed like the earth,<br> true to their vows, steady as Indra’s pillar,<br> like a lake clear of mud;<br> such a one does not transmigrate.\""},
 {t:"\"Their mind is peaceful,<br> peaceful are their speech and deeds.<br> Such a one is at peace,<br> rightly freed through enlightenment.\""},
 {t:"\"Lacking faith, a house-breaker,<br> one who acknowledges nothing,<br> purged of hope, they’ve wasted their chance:<br> that is indeed the supreme person!\""},
 {t:"\"Whether in village or wilderness,<br> in a valley or the uplands,<br> wherever the perfected ones live<br> is a delightful place.\""},
 {t:"\"Delightful are the wildernesses<br> where no people delight.<br> Those free of greed will delight there,<br> not those who seek sensual pleasures.\""},
 {t:"\"Better than a thousand<br> meaningless sayings<br> is a single meaningful saying,<br> hearing which brings you peace.\""},
 {t:"\"Better than a thousand<br> meaningless verses<br> is a single meaningful verse,<br> hearing which brings you peace.\""},
 {t:"\"Better than reciting<br> a hundred meaningless verses<br> is a single saying of Dhamma,<br> hearing which brings you peace.\""},
 {t:"\"The supreme conqueror is<br> not he who conquers a million men in battle,<br> but he who conquers a single man:<br> himself.\""},
 {t:"\"It is surely better to conquer oneself<br> than all those other folk.<br> When a person has tamed themselves,<br> always living restrained,\""},
 {t:"\"No god nor angel,<br> nor Māra nor divinity,<br> can undo the victory<br> of such a personage.\""},
 {t:"\"Rather than a thousandfold sacrifice,<br> every month for a full century,<br> it’s better to honor for a single hour<br> one who has developed themselves.<br> That offering is better<br> than the hundred year sacrifice.\""},
 {t:"\"Rather than serve the sacred flame<br> in the forest for a hundred years,<br> it’s better to honor for a single hour<br> a personage who has developed themselves.<br> That offering is better<br> than the hundred year sacrifice.\""},
 {t:"\"Whatever sacrifice or offering in the world<br> a seeker of merit may make for a year,<br> none of it is worth a quarter<br> of bowing to the sincere.\""},
 {t:"\"For one in the habit of bowing,<br> always honoring the elders,<br> four blessings grow:<br> lifespan, beauty, happiness, and strength.\""},
 {t:"\"Better to live a single day<br> ethical and absorbed in meditation<br> than to live a hundred years<br> unethical and lacking immersion.\""},
 {t:"\"Better to live a single day<br> wise and absorbed in meditation<br> than to live a hundred years<br> witless and lacking immersion.\""},
 {t:"\"Better to live a single day<br> energetic and strong,<br> than to live a hundred years<br> lazy and lacking energy.\""},
 {t:"\"Better to live a single day<br> seeing rise and fall<br> than to live a hundred years<br> blind to rise and fall.\""},
 {t:"\"Better to live a single day<br> seeing the state free of death<br> than to live a hundred years<br> blind to the state free of death.\""},
 {t:"\"Better to live a single day<br> seeing the supreme teaching<br> than to live a hundred years<br> blind to the supreme teaching.\""},
 {t:"\"Rush to do good,<br> shield your mind from evil;<br> for when you’re slow to do good,<br> your thoughts delight in wickedness.\""},
 {t:"\"If you do something bad,<br> don’t do it again and again,<br> don’t set your heart on it,<br> for piling up evil is suffering.\""},
 {t:"\"If you do something good,<br> do it again and again,<br> set your heart on it,<br> for piling up goodness is joyful.\""},
 {t:"\"Even the wicked see good things,<br> so long as their wickedness has not ripened.<br> But as soon as that wickedness ripens,<br> then the wicked see wicked things.\""},
 {t:"\"Even the good see wicked things,<br> so long as their goodness has not ripened.<br> But as soon as that goodness ripens,<br> then the good see good things.\""},
 {t:"\"Think not lightly of evil,<br> that it won’t come back to you.<br> The pot is filled with water<br> falling drop by drop;<br> the fool is filled with wickedness<br> piled up bit by bit.\""},
 {t:"\"Think not lightly of goodness,<br> that it won’t come back to you.<br> The pot is filled with water<br> falling drop by drop;<br> the attentive one is filled with goodness<br> piled up bit by bit.\""},
 {t:"\"Avoid wickedness,<br> as a merchant with rich cargo and small escort<br> would avoid a dangerous road,<br> or one who loves life would avoid drinking poison.\""},
 {t:"\"You can carry poison in your hand<br> if it has no wound,<br> for poison does not infect without a wound;<br> nothing bad happens unless you do bad.\""},
 {t:"\"Whoever wrongs a man who has done no wrong,<br> a pure man who has not a blemish,<br> the evil backfires on the fool,<br> like fine dust thrown upwind.\""},
 {t:"\"Some are born in a womb;<br> evil-doers go to hell;<br> the virtuous go to heaven;<br> the undefiled are fully extinguished.\""},
 {t:"\"Not in midair, nor mid-ocean,<br> nor hiding in a mountain cleft;<br> you’ll find no place on the planet<br> to escape your wicked deeds.\""},
 {t:"\"Not in midair, nor mid-ocean,<br> nor hiding in a mountain cleft;<br> you’ll find no place on the planet<br> where you won’t be vanquished by death.\""},
 {t:"\"All tremble at the rod,<br> all fear death.<br> Treating others like oneself,<br> neither kill nor incite to kill.\""},
 {t:"\"All tremble at the rod,<br> all love life.<br> Treating others like oneself,<br> neither kill nor incite to kill.\""},
 {t:"\"Creatures love happiness,<br> so if you harm them with a stick<br> in search of your own happiness,<br> after death you won’t find happiness.\""},
 {t:"\"Creatures love happiness,<br> so if you don’t harm them with a stick<br> in search of your own happiness,<br> after death you will find happiness.\""},
 {t:"\"Don’t speak harshly,<br> they may speak harshly back.<br> For aggressive speech is painful,<br> and the rod may spring back on you.\""},
 {t:"\"If you still yourself<br> like a broken gong,<br> you reach extinguishment<br> and know no conflict.\""},
 {t:"\"As a cowherd drives the cows<br> to pasture with the rod,<br> so too old age and death<br> drive life from living beings.\""},
 {t:"\"The fool does not understand<br> the evil that they do.<br> But because of those deeds, that simpleton<br> is tormented as if burnt by fire.\""},
 {t:"\"One who violently attacks<br> the peaceful and the innocent<br> swiftly falls<br> to one of ten bad states:\""},
 {t:"\"Or else their home<br> is consumed by fire.<br> When their body breaks up, that witless person<br> is reborn in hell.\""},
 {t:"\"Not nudity, nor matted hair, nor mud,<br> nor fasting, nor lying on bare ground,<br> nor wearing dust and dirt, or squatting on the heels,<br> will cleanse a mortal not free of doubt.\""},
 {t:"\"Dressed up they may be, but if they live well—<br> peaceful, tamed, committed to the spiritual path,<br> having laid aside violence towards all creatures—<br> they are a brahmin, an ascetic, a mendicant.\""},
 {t:"\"Can a person constrained by conscience<br> be found in the world?<br> Who shies away from blame,<br> like a fine horse from the whip?\""},
 {t:"\"Like a fine horse under the whip,<br> be keen and full of urgency.<br> With faith, ethics, and energy,<br> immersion, and investigation of principles,<br> accomplished in knowledge and conduct, mindful,<br> give up this vast suffering.\""},
 {t:"\"While irrigators guide water,<br> fletchers shape arrows,<br> and carpenters carve timber—<br> those true to their vows tame themselves.\""},
 {t:"\"What is joy, what is laughter,<br> when the flames are ever burning?<br> Shrouded by darkness,<br> would you not seek a light?\""},
 {t:"\"See this fancy puppet,<br> a body built of sores,<br> diseased, obsessed over,<br> in which nothing lasts at all.\""},
 {t:"\"This body is decrepit and frail,<br> a nest of disease.<br> This foul carcass falls apart,<br> for life ends in death.\""},
 {t:"\"These dove-grey bones<br> are tossed away like<br> dried gourds in the autumn—<br> what joy is there in such a sight?\""},
 {t:"\"In this city built of bones,<br> plastered with flesh and blood,<br> old age and death are stashed away,<br> along with conceit and contempt.\""},
 {t:"\"Fancy chariots of kings wear out,<br> and even this body gets old.<br> But the truth of the good never gets old—<br> so the good proclaim to the good.\""},
 {t:"\"A person of little learning<br> ages like an ox—<br> their flesh grows,<br> but not their wisdom.\""},
 {t:"\"Transmigrating through countless rebirths,<br> I’ve journeyed without reward,<br> searching for the house-builder;<br> painful is birth again and again.\""},
 {t:"\"I’ve seen you, house-builder!<br> You won’t build a house again!<br> Your rafters are all broken,<br> your roof-peak is demolished.<br> My mind, set on demolition,<br> has reached the end of craving.\""},
 {t:"\"When young they spurned the spiritual path<br> and failed to earn any wealth.<br> Now they brood like old cranes<br> in a pond bereft of fish.\""},
 {t:"\"When young they spurned the spiritual path<br> and failed to earn any wealth.<br> Now they lie like spent arrows,<br> bemoaning over things past.\""},
 {t:"\"If you knew your self as beloved,<br> you’d look after it so well.<br> In one of the night’s three watches,<br> an astute person would remain alert.\""},
 {t:"\"The astute would avoid being corrupted<br> by first grounding themselves<br> in what is suitable,<br> and then instructing others.\""},
 {t:"\"If one were to treat oneself<br> as one instructs another,<br> the well-tamed indeed would tame:<br> for the self, it seems, is hard to tame.\""},
 {t:"\"One is indeed the lord of oneself,<br> for who else would be one’s lord?<br> By means of a well-tamed self,<br> one gains a lord that’s rare indeed.\""},
 {t:"\"For the evil that is done by oneself,<br> born and produced in oneself,<br> grinds down a simpleton,<br> as diamond grinds a lesser gem.\""},
 {t:"\"One choked by immorality,<br> as a sal tree by a creeper,<br> does to themselves<br> what a foe only wishes.\""},
 {t:"\"It’s easy to do bad things<br> harmful to oneself,<br> but good things that are helpful<br> are the hardest things to do.\""},
 {t:"\"On account of wicked views—<br> scorning the guidance<br> of the perfected ones,<br> the noble ones living righteously—<br> the idiot begets their own self’s demise,<br> like the bamboo bearing fruit.\""},
 {t:"\"For it is by oneself that evil’s done,<br> one is corrupted by oneself.<br> It’s by oneself that evil’s not done,<br> one is purified by oneself.<br> Purity and impurity are personal matters,<br> no one can purify another.\""},
 {t:"\"Never neglect what is good for yourself<br> for the sake of another, however great.<br> Knowing well what is good for yourself,<br> be intent upon your heart’s goal.\""},
 {t:"\"Don’t resort to lowly things,<br> don’t abide in negligence,<br> don’t resort to wrong views,<br> don’t perpetuate the world.\""},
 {t:"\"Get up, don’t be heedless,<br> live by principle, with good conduct.<br> For one of good conduct sleeps at ease,<br> in this world and the next.\""},
 {t:"\"Live by principle, with good conduct,<br> don’t conduct yourself badly.<br> For one of good conduct sleeps at ease,<br> in this world and the next.\""},
 {t:"\"Look upon the world<br> as a bubble<br> or a mirage,<br> then the King of Death won’t see you.\""},
 {t:"\"Come, see this world decked out<br> like a fancy royal chariot.<br> Here fools founder,<br> but the discerning are not chained.\""},
 {t:"\"He who once was heedless,<br> but turned to heedfulness,<br> lights up the world<br> like the moon freed from clouds.\""},
 {t:"\"Someone whose bad deed<br> is supplanted by the good,<br> lights up the world,<br> like the moon freed from clouds.\""},
 {t:"\"Blind is the world,<br> few are those who clearly see.<br> Only a handful go to heaven,<br> like a bird freed from a net.\""},
 {t:"\"Swans fly by the sun’s path,<br> psychic sages fly through space.<br> The attentive leave the world,<br> having vanquished Māra with his legions.\""},
 {t:"\"When a personage, spurning the hereafter,<br> transgresses in just one thing—<br> lying—<br> there is no evil they would not do.\""},
 {t:"\"The miserly don’t ascend to heaven,<br> it takes a fool to not praise giving.<br> The attentive celebrate giving,<br> and so find happiness in the hereafter.\""},
 {t:"\"The fruit of stream-entry is better<br> than being the one king of the earth,<br> than going to heaven,<br> than lordship over all the world.\""},
 {t:"\"He whose victory may not be undone,<br> a victory unrivaled in all the world;<br> by what track would you trace that Buddha,<br> who leaves no track in his infinite range?\""},
 {t:"\"Of craving, the weaver, the clinger, he has none:<br> so where can he be traced?<br> By what track would you trace that Buddha,<br> who leaves no track in his infinite range?\""},
 {t:"\"The attentive intent on absorption,<br> who love the peace of renunciation,<br> the Buddhas, ever mindful,<br> are envied by even the gods.\""},
 {t:"\"It’s hard to gain a human birth;<br> the life of mortals is hard;<br> it’s hard to hear the true teaching;<br> the arising of Buddhas is hard.\""},
 {t:"\"Not to do any evil;<br> to embrace the good;<br> to purify one’s mind:<br> this is the instruction of the Buddhas.\""},
 {t:"\"Patient acceptance is the ultimate fervor.<br> Extinguishment is the ultimate, say the Buddhas.<br> No true renunciate injures another,<br> nor does an ascetic hurt another.\""},
 {t:"\"Not speaking ill nor doing harm;<br> restraint in the monastic code;<br> moderation in eating;<br> staying in remote lodgings;<br> commitment to the higher mind—<br> this is the instruction of the Buddhas.\""},
 {t:"\"Even if it were raining money,<br> you’d not be sated in sensual pleasures.<br> An astute person understands that sensual pleasures<br> offer little gratification and much suffering.\""},
 {t:"\"Thus they find no delight<br> even in celestial pleasures.<br> A disciple of the fully awakened Buddha<br> delights in the ending of craving.\""},
 {t:"\"So many go for refuge<br> to mountains and forest groves,<br> to shrines in tended parks;<br> those people are driven by fear.\""},
 {t:"\"But such refuge is no sanctuary,<br> it is no supreme refuge.<br> By going to that refuge,<br> you’re not released from all suffering.\""},
 {t:"\"One gone for refuge to the Buddha,<br> to his teaching and to the Saṅgha,<br> sees the four noble truths<br> with right understanding:\""},
 {t:"\"Suffering, suffering’s origin,<br> suffering’s transcendence,<br> and the noble eightfold path<br> that leads to the stilling of suffering.\""},
 {t:"\"Such refuge is a sanctuary,<br> it is the supreme refuge.<br> By going to that refuge,<br> you’re released from all suffering.\""},
 {t:"\"It’s hard to find a thoroughbred man:<br> they’re not born just anywhere.<br> A family where that attentive one is born<br> prospers in happiness.\""},
 {t:"\"Happy, the arising of Buddhas!<br> Happy, the teaching of Dhamma!<br> Happy is the harmony of the Saṅgha,<br> and the striving of the harmonious is happy.\""},
 {t:"\"When a person venerates the worthy—<br> the Buddha or his disciple,<br> who have transcended proliferation,<br> and have left behind grief and lamentation,\""},
 {t:"\"Fearing nothing from any quarter—<br> the merit of one venerating such as these,<br> cannot be calculated by anyone,<br> saying it is just this much.\""},
 {t:"\"Let us live so very happily,<br> loving among the hostile.<br> Among hostile humans,<br> let us live with love.\""},
 {t:"\"Let us live so very happily,<br> healthy among the ailing.<br> Among ailing humans<br> let us live healthily.\""},
 {t:"\"Let us live so very happily,<br> content among the greedy.<br> Among greedy humans,<br> let us live content.\""},
 {t:"\"Let us live so very happily,<br> we who have nothing.<br> We shall feed on rapture,<br> like the gods of streaming radiance.\""},
 {t:"\"Victory breeds enmity;<br> the defeated sleep badly.<br> The peaceful sleep at ease,<br> having left victory and defeat behind.\""},
 {t:"\"There is no fire like greed,<br> no crime like hate,<br> no suffering like the aggregates,<br> no bliss beyond peace.\""},
 {t:"\"Hunger is the worst illness,<br> conditions are the worst suffering.<br> For one who truly knows this,<br> extinguishment is the ultimate happiness.\""},
 {t:"\"Health is the ultimate blessing;<br> contentment, the ultimate wealth;<br> trust is the ultimate family;<br> extinguishment, the ultimate happiness.\""},
 {t:"\"Having drunk the nectar of seclusion<br> and the nectar of peace—<br> free of stress, free of evil,<br> drink the joyous nectar of truth.\""},
 {t:"\"It’s good to see the noble ones,<br> staying with them is always good.<br> Were you not to see fools,<br> you’d always be happy.\""},
 {t:"\"For one who consorts with fools<br> grieves long.<br> Painful is living with fools,<br> like being stuck with your enemy.<br> Happy is living with an attentive one,<br> like meeting with your kin.\""},
 {t:"\"Therefore:<br> An attentive one, wise and learned,<br> a behemoth of virtue, true to their vows, noble:<br> follow a true and intelligent person such as this,<br> as the moon tracks the path of the stars.\""},
 {t:"\"Applying yourself where you ought not,<br> neglecting what you should be doing,<br> forgetting your goal, you cling to what you hold dear,<br> jealous of those devoted to their heart’s goal.\""},
 {t:"\"Don’t ever get too close<br> to those you like or dislike.<br> For not seeing the liked is suffering,<br> and so is seeing the disliked.\""},
 {t:"\"Therefore don’t hold anything dear,<br> for it’s bad to lose those you love.<br> No ties are found in they who<br> hold nothing loved or loathed.\""},
 {t:"\"Sorrow springs from what we hold dear,<br> fear springs from what we hold dear;<br> one free from holding anything dear<br> has no sorrow, let alone fear.\""},
 {t:"\"Sorrow springs from attachment,<br> fear springs from attachment;<br> one free from attachment<br> has no sorrow, let alone fear.\""},
 {t:"\"Sorrow springs from relishing,<br> fear springs from relishing;<br> one free from relishing<br> has no sorrow, let alone fear.\""},
 {t:"\"Sorrow springs from desire,<br> fear springs from desire;<br> one free from desire<br> has no sorrow, let alone fear.\""},
 {t:"\"Sorrow springs from craving,<br> fear springs from craving;<br> one free from craving<br> has no sorrow, let alone fear.\""},
 {t:"\"One accomplished in virtue and vision,<br> firmly principled, and truthful,<br> doing oneself what ought be done:<br> that’s who the people love.\""},
 {t:"\"One eager to realize the ineffable<br> would be filled with awareness.<br> Their mind not bound to pleasures of sense,<br> they’re said to be heading upstream.\""},
 {t:"\"When a man returns safely<br> after a long time spent abroad,<br> family, friends, and loved ones<br> celebrate his return.\""},
 {t:"\"Just so, when one who has done good<br> goes from this world to the next,<br> their good deeds receive them there,<br> as family welcomes home one they love.\""},
 {t:"\"Give up anger, get rid of conceit,<br> and escape every fetter.<br> Sufferings don’t befall one who has nothing,<br> not clinging to name and form.\""},
 {t:"\"When anger surges like a lurching chariot,<br> keep it in check.<br> That’s what I call a charioteer;<br> others just hold the reins.\""},
 {t:"\"Defeat anger with kindness,<br> villainy with virtue,<br> stinginess with giving,<br> and lies with truth.\""},
 {t:"\"Speak the truth, do not be angry,<br> and give when asked, if only a little.<br> By these three means,<br> you may enter the presence of the gods.\""},
 {t:"\"Those harmless sages,<br> always restrained in body,<br> go to the state that does not pass,<br> where there is no sorrow.\""},
 {t:"\"Always wakeful,<br> practicing night and day,<br> focused only on extinguishment,<br> their defilements come to an end.\""},
 {t:"\"It’s always been this way, Atula,<br> it’s not just today.<br> They blame you when you’re silent,<br> they blame you when you speak a lot,<br> and even when you speak just right:<br> no-one in the world escapes blame.\""},
 {t:"\"There never was, nor will be,<br> nor is there today,<br> someone who is wholly praised<br> or wholly blamed.\""},
 {t:"\"If, after watching them day in day out,<br> discerning people praise<br> that sage of impeccable conduct,<br> endowed with ethics and wisdom;\""},
 {t:"\"like a pendant of Black Plum River gold,<br> who is worthy to criticize them?<br> Even the gods praise them,<br> and by the Divinity, too, they’re praised.\""},
 {t:"\"Guard against ill-tempered deeds,<br> be restrained in body.<br> Giving up bad bodily conduct,<br> conduct yourself well in body.\""},
 {t:"\"Guard against ill-tempered words,<br> be restrained in speech.<br> Giving up bad verbal conduct,<br> conduct yourself well in speech.\""},
 {t:"\"Guard against ill-tempered thoughts,<br> be restrained in mind.<br> Giving up bad mental conduct,<br> conduct yourself well in mind.\""},
 {t:"\"An attentive one is restrained in body<br> restrained also in speech,<br> in thought, too, they are restrained:<br> they are restrained in every way.\""},
 {t:"\"Today you’re like a withered leaf,<br> Yama’s men await you.<br> You stand at the departure gates,<br> yet you have no supplies for the road.\""},
 {t:"\"Make an island of yourself!<br> Swiftly strive, learn to be wise!<br> Purged of stains, flawless,<br> you’ll go to the heavenly realm of the noble ones.\""},
 {t:"\"You’ve journeyed the stages of life,<br> and now you set out to meet Yama.<br> Along the way there’s nowhere to stay,<br> yet you have no supplies for the road.\""},
 {t:"\"Make an island of yourself!<br> Swiftly strive, learn to be wise!<br> Purged of stains, flawless,<br> you’ll not come again to rebirth and old age.\""},
 {t:"\"A smart person would purge<br> their own stains gradually,<br> bit by bit, moment by moment,<br> like a smith smelting silver.\""},
 {t:"\"It is the rust born on the iron<br> that eats away the place it arose.<br> And so it is their own deeds<br> that lead the overly-ascetic to a bad place.\""},
 {t:"\"Not rehearsing is the stain of hymns.<br> The stain of houses is neglect.<br> Laziness is the stain of beauty.<br> A guard’s stain is negligence.\""},
 {t:"\"Misconduct is a woman’s stain.<br> A giver’s stain is stinginess.<br> Bad qualities are a stain<br> in this world and the next.\""},
 {t:"\"But a worse stain than these<br> is ignorance, the worst stain of all.<br> Having given up that stain,<br> be without stains, mendicants!\""},
 {t:"\"Life is easy for the shameless.<br> With all the rude courage of a crow,<br> they live pushy,<br> rude, and corrupt.\""},
 {t:"\"Life is hard for the conscientious,<br> always seeking purity,<br> neither clinging nor rude,<br> pure of livelihood and discerning.\""},
 {t:"\"Take anyone in this world<br> who kills living creatures,<br> speaks falsely, steals,<br> commits adultery,\""},
 {t:"\"and indulges in drinking<br> beer and wine.<br> Right here they dig up<br> the root of their own self.\""},
 {t:"\"Know this, good fellow:<br> they are unrestrained and wicked.<br> Don’t let that greed and unrighteousness<br> inflict pain on you for long.\""},
 {t:"\"The people give according to their faith,<br> according to their confidence.<br> If you get upset over that,<br> over other’s food and drink,<br> you’ll not, by day or by night,<br> become immersed in samādhi.\""},
 {t:"\"Those who have cut that out,<br> dug it up at the root, eradicated it,<br> they will, by day or by night,<br> become immersed in samādhi.\""},
 {t:"\"There is no fire like greed,<br> no crime like hate,<br> no net like delusion,<br> no river like craving.\""},
 {t:"\"It’s easy to see the faults of others,<br> hard to see one’s own.<br> For the faults of others<br> are tossed high like hay,<br> while one’s own are hidden,<br> as a cheat hides a bad hand.\""},
 {t:"\"When you look for the flaws of others,<br> always finding fault,<br> your defilements only grow,<br> you’re far from ending defilements.\""},
 {t:"\"In the atmosphere there is no track,<br> there’s no true ascetic outside here.<br> People enjoy proliferation,<br> the Realized Ones are free of proliferation.\""},
 {t:"\"In the atmosphere there is no track,<br> there’s no true ascetic outside here.<br> No conditions last forever,<br> the Awakened Ones are not shaken.\""},
 {t:"\"You don’t become just<br> by passing hasty judgment.<br> An astute person evaluates both<br> what is pertinent and what is irrelevant.\""},
 {t:"\"A wise one judges others without haste,<br> justly and impartially;<br> that guardian of the law<br> is said to be just.\""},
 {t:"\"You’re not an astute scholar<br> just because you speak a lot.<br> One who is secure, free of enmity and fear,<br> is said to be astute.\""},
 {t:"\"You’re not one who has memorized the teaching<br> just because you recite a lot.<br> Someone who directly sees the teaching<br> after hearing only a little<br> is truly one who has memorized the teaching,<br> for they can never forget it.\""},
 {t:"\"You don’t become a senior<br> by getting some grey hairs;<br> for one ripe only in age,<br> is said to have aged in vain.\""},
 {t:"\"One who is truthful and principled,<br> harmless, restrained, and self-controlled,<br> attentive, purged of stains,<br> is said to be a senior.\""},
 {t:"\"Not by mere enunciation,<br> or a beautiful complexion<br> does a person become holy,<br> if they’re jealous, stingy, and devious.\""},
 {t:"\"But if they’ve cut that out,<br> dug it up at the root, eradicated it,<br> that wise one, purged of vice,<br> is said to be holy.\""},
 {t:"\"A liar and breaker of vows is no ascetic<br> just because they shave their head.<br> How on earth can one be an ascetic<br> who’s full of desire and greed?\""},
 {t:"\"One who stops all wicked deeds,<br> great and small,<br> because of stopping wicked deeds<br> is said to be an ascetic.\""},
 {t:"\"You don’t become a mendicant<br> just by begging from others.<br> One who has undertaken domestic duties<br> has not yet become a mendicant.\""},
 {t:"\"But one living a spiritual life,<br> who has banished both merit and evil,<br> who wanders having appraised the world,<br> is said to be a mendicant.\""},
 {t:"\"You don’t become a sage by being sagelike,<br> while still confused and ignorant.<br> The astute one who holds the scales,<br> taking only the best,\""},
 {t:"\"And shunning the bad—<br> that is a sage,<br> and that is how one becomes a sage.<br> One who sagely weighs both in the world,<br> is thereby said to be a sage.\""},
 {t:"\"You don’t become a noble one<br> by harming living beings.<br> One harmless towards all living beings<br> is said to be a noble one.\""},
 {t:"\"Not by precepts and observances,<br> nor by much learning,<br> nor by meditative immersion,<br> nor by living in seclusion,\""},
 {t:"\"Do I experience the bliss of renunciation<br> not frequented by ordinary people.<br> A mendicant cannot rest confident<br> without attaining the end of defilements.\""},
 {t:"\"Of paths, the eightfold is the best;<br> of truths, the four statements;<br> dispassion is the best of things,<br> and the Clear-eyed One is the best of humans.\""},
 {t:"\"This is the path, there is no other<br> for the purification of vision.<br> You all must practice this,<br> it is the way to baffle Māra.\""},
 {t:"\"When you all are practicing this,<br> you will make an end of suffering.<br> I have explained the path to you<br> for extracting the thorn with wisdom.\""},
 {t:"\"You yourselves must do the work,<br> the Realized Ones just show the way.<br> Meditators practicing absorption<br> are released from Māra’s bonds.\""},
 {t:"\"All conditions are impermanent—<br> when this is seen with wisdom,<br> one grows disillusioned with suffering:<br> this is the path to purity.\""},
 {t:"\"All conditions are suffering—<br> when this is seen with wisdom,<br> one grows disillusioned with suffering:<br> this is the path to purity.\""},
 {t:"\"All things are not-self—<br> when this is seen with wisdom,<br> one grows disillusioned with suffering:<br> this is the path to purity.\""},
 {t:"\"They don’t get going when it’s time to start;<br> they’re young and strong, but given to sloth.<br> Their mind depressed in sunken thought,<br> lazy and slothful, they can’t discern the path.\""},
 {t:"\"Guarded in speech, restrained in mind,<br> doing no unskillful bodily deed.<br> Purify these three ways of performing deeds,<br> and win the path known to seers.\""},
 {t:"\"From meditation springs wisdom,<br> without meditation, wisdom ends.<br> Knowing these two paths—<br> of progress and decline—<br> you should conduct yourself<br> so that wisdom grows.\""},
 {t:"\"Cut down the jungle, not just a tree;<br> from the jungle springs fear.<br> Having cut down jungle and snarl,<br> be free of jungles, mendicants!\""},
 {t:"\"So long as the vine, no matter how small,<br> that ties a man to women is not cut,<br> his mind remains trapped,<br> like a calf suckling its mother.\""},
 {t:"\"Cut out affection for oneself,<br> like plucking an autumn lotus.<br> Foster only the path to peace,<br> the extinguishment the Holy One taught.\""},
 {t:"\"“Here I will stay for the rains;<br> here for winter, here the summer”;<br> thus the fool thinks,<br> not realizing the danger.\""},
 {t:"\"As a mighty flood sweeps away a sleeping village,<br> death steals away a man<br> who dotes on children and cattle,<br> his mind caught up in them.\""},
 {t:"\"Children provide you no shelter,<br> nor does father, nor relatives.<br> When you’re seized by the terminator,<br> there’s no shelter in family.\""},
 {t:"\"Knowing the reason for this,<br> astute, and ethically restrained,<br> one would quickly clear the path<br> that leads to extinguishment.\""},
 {t:"\"If by giving up material happiness<br> one sees abundant happiness,<br> the attentive would give up material happiness,<br> seeing the abundant happiness.\""},
 {t:"\"Seeking their own happiness<br> by imposing suffering on others,<br> living intimate with enmity,<br> they’re not freed from enmity.\""},
 {t:"\"They dump what should be done,<br> and do what should not be done.<br> For the insolent and the negligent,<br> their defilements only grow.\""},
 {t:"\"Those that have properly undertaken<br> constant mindfulness of the body,<br> don’t cultivate what should not be done,<br> but always do what should be done.<br> Mindful and aware,<br> their defilements come to an end.\""},
 {t:"\"Having slain mother and father,<br> and two aristocratic kings,<br> and having wiped out<br> the kingdom with its tax collector,<br> the brahmin walks on untroubled.\""},
 {t:"\"Having slain mother and father,<br> and two prosperous kings,<br> and a tiger as the fifth,<br> the brahmin walks on untroubled.\""},
 {t:"\"The disciples of Gotama<br> always wake up refreshed,<br> who day and night<br> constantly recollect the Buddha.\""},
 {t:"\"The disciples of Gotama<br> always wake up refreshed,<br> who day and night<br> constantly recollect the teaching.\""},
 {t:"\"The disciples of Gotama<br> always wake up refreshed,<br> who day and night<br> constantly recollect the Saṅgha.\""},
 {t:"\"The disciples of Gotama<br> always wake up refreshed,<br> who day and night<br> are constantly mindful of the body.\""},
 {t:"\"The disciples of Gotama<br> always wake up refreshed,<br> whose minds day and night<br> delight in harmlessness.\""},
 {t:"\"The disciples of Gotama<br> always wake up refreshed,<br> whose minds day and night<br> delight in meditation.\""},
 {t:"\"Going forth is hard, it’s hard to be happy;<br> life at home is hard too, and painful,<br> it’s painful to stay when you’ve nothing in common.<br> A traveler is a prey to pain,<br> so don’t be a traveler,<br> don’t be prey to pain.\""},
 {t:"\"One who is faithful, accomplished in ethics,<br> blessed with fame and wealth,<br> is honored in whatever place<br> they frequent.\""},
 {t:"\"The good shine from afar,<br> like the Himalayan peaks,<br> but the wicked are not seen,<br> like arrows scattered in the night.\""},
 {t:"\"Sitting alone, sleeping alone,<br> tirelessly wandering alone;<br> one who tames themselves alone<br> would delight within a forest.\""},
 {t:"\"A liar goes to hell,<br> as does one who denies what they did.<br> Both are equal in the hereafter,<br> those men of base deeds.\""},
 {t:"\"Many who wear a scrap of ocher cloth<br> are unrestrained and wicked.<br> Being wicked, they are reborn in hell<br> due to their bad deeds.\""},
 {t:"\"It’d be better for the immoral and unrestrained<br> to eat an iron ball,<br> scorching, like a burning flame,<br> than to eat the nation’s alms.\""},
 {t:"\"Four things befall a heedless man<br> who sleeps with another’s wife:<br> wickedness, poor sleep,<br> ill-repute, and rebirth in hell.\""},
 {t:"\"He accrues wickedness and is reborn in a bad place,<br> all so a frightened couple<br> may snatch a moment’s pleasure,<br> for which rulers impose a heavy punishment.<br> That’s why a man should not<br> sleep with another’s wife.\""},
 {t:"\"When kusa grass is wrongly grasped<br> it only cuts the hand.<br> So too, the ascetic life, when wrongly taken,<br> drags you to hell.\""},
 {t:"\"Any lax act,<br> any corrupt observance,<br> or suspicious spiritual life,<br> is not very fruitful.\""},
 {t:"\"If one is to do what should be done,<br> one should staunchly strive.<br> For the life gone forth when laxly led<br> just stirs up dust all the more.\""},
 {t:"\"A bad deed is better left undone,<br> for it will plague you later on.<br> A good deed is better done,<br> one that does not plague you.\""},
 {t:"\"As a frontier city<br> is guarded inside and out,<br> so you should ward yourselves—<br> don’t let the moment pass you by.<br> For if you miss your moment<br> you’ll grieve when sent to hell.\""},
 {t:"\"Unashamed of what is shameful,<br> ashamed of what is not shameful;<br> beings who uphold wrong view<br> go to a bad place.\""},
 {t:"\"Seeing danger where there is none,<br> and blind to the actual danger,<br> beings who uphold wrong view<br> go to a bad place.\""},
 {t:"\"Seeing fault where there is none,<br> and blind to the actual fault,<br> beings who uphold wrong view<br> go to a bad place.\""},
 {t:"\"Knowing a fault as a fault<br> and the faultless as faultless,<br> beings who uphold right view<br> go to a good place.\""},
 {t:"\"Like an elephant struck<br> with arrows in battle,<br> I shall withstand abuse,<br> for so many folk are badly behaved.\""},
 {t:"\"The well-tamed beast is the one led to the crowd;<br> the tamed elephant’s the one the king mounts;<br> the tamed person who withstands abuse<br> is the best of human beings.\""},
 {t:"\"Those who have tamed themselves are better<br> than fine tamed mules,<br> thoroughbreds from Sindh,<br> or giant tuskers.\""},
 {t:"\"For not on those mounts<br> would you go to the untrodden place,<br> whereas, with the help of one<br> whose self is well tamed,<br> you go there, tamed by the tamed.\""},
 {t:"\"The tusker named Dhanapāla<br> is musky in rut, hard to control.<br> Bound, he eats not a morsel,<br> for he misses the elephant forest.\""},
 {t:"\"One who gets drowsy from overeating,<br> fond of sleep, rolling round the bed<br> like a great hog stuffed with grain:<br> that dullard returns to the womb again and again.\""},
 {t:"\"In the past my mind wandered<br> how it wished, where it liked, as it pleased.<br> Now I’ll carefully guide it,<br> as a trainer with a hook guides a rutting elephant.\""},
 {t:"\"Delight in diligence!<br> Take good care of your mind!<br> Pull yourself out of this pit,<br> like an elephant sunk in a bog.\""},
 {t:"\"If you find an alert companion,<br> an attentive friend to live happily together,<br> then, overcoming all adversities,<br> wander with them, joyful and mindful.\""},
 {t:"\"If you find no alert companion,<br> no attentive friend to live happily together,<br> then, like a king who flees his conquered realm,<br> wander alone like a tusker in the wilds.\""},
 {t:"\"It’s better to wander alone,<br> there’s no fellowship with fools.<br> Wander alone and do no wrong,<br> at ease like a tusker in the wilds.\""},
 {t:"\"A friend in need is a blessing;<br> it’s a blessing to be content with whatever;<br> good deeds are a blessing at the end of life,<br> and giving up all suffering is a blessing.\""},
 {t:"\"In this world it’s a blessing to serve<br> one’s mother and one’s father.<br> And it’s a blessing also to serve<br> ascetics and brahmins.\""},
 {t:"\"It’s a blessing to keep precepts until you grow old;<br> a blessing to be grounded in faith;<br> the getting of wisdom’s a blessing;<br> and it’s a blessing to avoid doing wrong.\""},
 {t:"\"When a man lives heedlessly,<br> craving grows in them like a camel’s foot creeper.<br> They jump from one thing to the next, like a langur<br> greedy for fruit in a forest grove.\""},
 {t:"\"Whoever is beaten by this wretched craving,<br> this attachment to the world,<br> their sorrow grows,<br> like grass in the rain.\""},
 {t:"\"But whoever prevails over this wretched craving,<br> so hard to get over in the world,<br> their sorrows fall from them,<br> like a drop from a lotus-leaf.\""},
 {t:"\"I say this to you, good people,<br> all those who have gathered here:<br> dig up the root of craving,<br> as you’d dig up grass in search of roots.<br> Don’t let Māra break you again and again,<br> like a stream breaking a reed.\""},
 {t:"\"A tree grows back even when cut down,<br> so long as its roots are strong and undamaged;<br> suffering springs up again and again,<br> so long as the tendency to craving is not pulled out.\""},
 {t:"\"A person of low views<br> in whom the thirty-six streams<br> that flow to pleasure are mighty,<br> is swept away by lustful thoughts.\""},
 {t:"\"The streams flow everywhere;<br> a weed springs up and remains.<br> Seeing this weed that has been born,<br> cut the root with wisdom.\""},
 {t:"\"A personage’s joys<br> flow from senses and cravings.<br> Seekers of happiness, bent on pleasure,<br> continue to be reborn and grow old.\""},
 {t:"\"People governed by thirst,<br> crawl about like a trapped rabbit.<br> Bound and fettered, for a long time<br> they return to pain time and again.\""},
 {t:"\"People governed by thirst,<br> crawl about like a trapped rabbit.<br> That’s why one who longs for dispassion<br> should dispel thirst.\""},
 {t:"\"Unsnarled, they set out for the jungle,<br> then they run right back to the jungle they left behind.<br> Just look at this individual!<br> Freed, they run to bondage.\""},
 {t:"\"The attentive say that shackle is not strong<br> that’s made of iron, wood, or knots.<br> But obsession with jeweled earrings,<br> concern for your partners and children:\""},
 {t:"\"This, say the attentive, is a strong shackle<br> dragging the indulgent down, hard to escape.<br> Having cut this one too they go forth,<br> unconcerned, having given up sensual pleasures.\""},
 {t:"\"Besotted by lust they fall into the stream,<br> like a spider caught in the web she wove.<br> The attentive proceed, having cut this one too,<br> unconcerned, having given up all suffering.\""},
 {t:"\"Let go of the past, let go of the future,<br> let go of the present, having gone beyond rebirth.<br> With your heart freed in every respect,<br> you’ll not come again to rebirth and old age.\""},
 {t:"\"For a personage churned by thoughts,<br> very lustful, focusing on beauty,<br> their craving grows and grows,<br> tying them with a stout bond.\""},
 {t:"\"But one who loves to calm their thoughts,<br> developing perception of ugliness, ever mindful,<br> will surely eliminate that craving,<br> cutting off the bonds of Māra.\""},
 {t:"\"One who is confident, unafraid,<br> rid of craving, free of blemish,<br> having struck down the arrows flying to future lives,<br> this bag of bones is their last.\""},
 {t:"\"Rid of craving, free of grasping,<br> expert in the definition of terms,<br> knowing the correct<br> structure and sequence of syllables,<br> they are said to be one who bears their final body,<br> one of great wisdom, a great person.\""},
 {t:"\"I am the champion, the knower of all,<br> unsullied in the midst of all things.<br> I’ve given up all, freed in the ending of craving.<br> Since I know for myself, whose follower should I be?\""},
 {t:"\"The gift of the teaching surmounts all other gifts;<br> the taste of the teaching surmounts all other tastes;<br> the joy of the teaching surmounts all other joys;<br> the ending of craving surmounts all suffering.\""},
 {t:"\"Riches ruin a simpleton,<br> but not a seeker of the far shore.<br> From craving for wealth, a simpleton<br> ruins themselves and others.\""},
 {t:"\"Weeds are the bane of crops,<br> but greed is these folk’s bane.<br> That’s why a gift to one rid of greed<br> is so very fruitful.\""},
 {t:"\"Weeds are the bane of crops,<br> but hate is these folk’s bane.<br> That’s why a gift to one rid of hate<br> is so very fruitful.\""},
 {t:"\"Weeds are the bane of crops,<br> but delusion is these folk’s bane.<br> That’s why a gift to one rid of delusion<br> is so very fruitful.\""},
 {t:"\"Weeds are the bane of crops,<br> but desire is these folk’s bane.<br> That’s why a gift to one rid of desire<br> is so very fruitful.\""},
 {t:"\"Restraint of the eye is good;<br> good is restraint of the ear;<br> restraint of the nose is good;<br> good is restraint of the tongue.\""},
 {t:"\"Restraint of the body is good;<br> good is restraint of speech;<br> restraint of mind is good;<br> everywhere, restraint is good.<br> The mendicant restrained everywhere<br> is released from all suffering.\""},
 {t:"\"One restrained in hand and foot,<br> and in speech, the supreme restraint;<br> happy inside, serene,<br> solitary, content, I call a mendicant.\""},
 {t:"\"When a mendicant of restrained mouth,<br> thoughtful in counsel, not restless,<br> explains the text and its meaning,<br> their words are sweet.\""},
 {t:"\"Delighting in the teaching, enjoying the teaching,<br> contemplating the teaching,<br> a mendicant who recollects the teaching<br> doesn’t fall away from the true teaching.\""},
 {t:"\"A well-off mendicant ought not look down<br> on others, nor should they be envious.<br> A mendicant who envies others<br> does not achieve immersion.\""},
 {t:"\"If a mendicant is poor in offerings,<br> the well-to-do ought not look down on them.<br> For the gods indeed praise them,<br> who are tireless and pure of livelihood.\""},
 {t:"\"One who has no sense of ownership<br> in the whole realm of name and form,<br> who does not grieve for that which is not,<br> is said to be a mendicant.\""},
 {t:"\"A mendicant who meditates on love,<br> devoted to the Buddha’s teaching,<br> would realize the peaceful state,<br> the blissful stilling of conditions.\""},
 {t:"\"Bail out this boat, mendicant!<br> When bailed out it will float lightly.<br> Having cut off desire and hate,<br> you shall reach extinguishment.\""},
 {t:"\"Five to cut, five to drop,<br> and five more to develop.<br> When a mendicant slips five chains<br> they’re said to have crossed the flood.\""},
 {t:"\"Practice absorption, don’t be negligent!<br> Don’t let the mind delight in the senses!<br> Don’t heedlessly swallow a hot iron ball!<br> And when it burns, don’t cry, “Oh, the pain!”\""},
 {t:"\"No absorption for one without wisdom,<br> no wisdom for one without absorption.<br> But one with absorption and wisdom—<br> they have truly drawn near to extinguishment.\""},
 {t:"\"A mendicant who enters an empty hut<br> with mind at peace<br> finds a superhuman delight<br> as they rightly discern the Dhamma.\""},
 {t:"\"Whenever they are mindful<br> of the rise and fall of the aggregates,<br> they feel rapture and joy:<br> that is freedom from death for one who knows.\""},
 {t:"\"This is the very start of the path<br> for a wise mendicant:<br> guarding the senses, contentment,<br> and restraint in the monastic code.\""},
 {t:"\"Mix with spiritual friends,<br> who are tireless and pure of livelihood.<br> Share what you have with others,<br> being skillful in your conduct.<br> And when you’re full of joy,<br> you’ll make an end to suffering.\""},
 {t:"\"As a jasmine sheds<br> its withered flowers,<br> O mendicants,<br> shed greed and hate.\""},
 {t:"\"Calm in body, calm in speech,<br> peaceful and serene;<br> a mendicant who’s spat out the world’s bait<br> is said to be one at peace.\""},
 {t:"\"Urge yourself on,<br> reflect on yourself.<br> A mendicant self-controlled and mindful<br> will always dwell in happiness.\""},
 {t:"\"Self is indeed the lord of self,<br> for who else would be one’s lord?<br> Self is indeed the home of self,<br> so restrain yourself,<br> as a merchant his thoroughbred steed.\""},
 {t:"\"A monk full of joy<br> trusting in the Buddha’s teaching,<br> would realize the peaceful state,<br> the blissful stilling of conditions.\""},
 {t:"\"A young mendicant<br> devoted to the Buddha’s teaching,<br> lights up the world,<br> like the moon freed from clouds.\""},
 {t:"\"Cut the stream, striving!<br> Cast aside sensual pleasures, brahmin.<br> Knowing the ending of conditions,<br> know the uncreated, brahmin.\""},
 {t:"\"When a brahmin has gone beyond<br> dualistic phenomena,<br> then they consciously<br> make an end of all fetters.\""},
 {t:"\"One for whom there is no crossing over<br> or crossing back, or crossing over and back;<br> stress-free, detached,<br> that’s who I declare a brahmin.\""},
 {t:"\"Absorbed, rid of hopes,<br> their task completed, without defilements,<br> arrived at the highest goal:<br> that’s who I declare a brahmin.\""},
 {t:"\"The sun blazes by day,<br> the moon radiates at night,<br> the aristocrat shines in armor,<br> and the brahmin shines in absorption.<br> But all day and all night,<br> the Buddha blazes with glory.\""},
 {t:"\"A brahmin’s so-called<br> since they’ve banished evil,<br> an ascetic’s so-called<br> since they live a serene life.<br> One who has renounced all stains<br> is said to be a “renunciant”.\""},
 {t:"\"One should never strike a brahmin,<br> nor should a brahmin retaliate.<br> Woe to the one who hurts a brahmin,<br> and woe for the one who retaliates.\""},
 {t:"\"Nothing is better for a brahmin<br> than to hold their mind back from attachment.<br> From wherever a cruel wish recoils,<br> right there suffering subsides.\""},
 {t:"\"Who does nothing wrong<br> by body, speech or mind,<br> restrained in these three respects,<br> that’s who I declare a brahmin.\""},
 {t:"\"You should graciously honor<br> the one from whom you learn the Dhamma<br> taught by the awakened Buddha,<br> as a brahmin honors the sacred flame.\""},
 {t:"\"Not by matted hair or family,<br> or birth is one a brahmin.<br> Those who are truthful and principled:<br> they are pure, they are brahmins.\""},
 {t:"\"Why the matted hair, you simpleton,<br> and why the skin of deer?<br> The tangle is inside you,<br> yet you polish up your outsides.\""},
 {t:"\"A personage who wears robes of rags,<br> lean, their limbs showing veins,<br> meditating alone in the forest,<br> that’s who I declare a brahmin.\""},
 {t:"\"I don’t call someone a brahmin<br> after the mother’s womb they’re born from.<br> If they still have attachments,<br> they’re just someone who says “worthy”.<br> Having nothing, taking nothing:<br> that’s who I declare a brahmin.\""},
 {t:"\"Having cut off all fetters<br> they have no anxiety.<br> They’ve slipped their chains and are detached:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve cut the strap and harness,<br> the halter and bridle too,<br> with cross-bar lifted, they’re awakened:<br> that’s who I declare a brahmin.\""},
 {t:"\"Abuse, killing, caging:<br> they withstand these without anger.<br> Patience is their powerful army:<br> that’s who I declare a brahmin.\""},
 {t:"\"Not irritable or pretentious,<br> dutiful in precepts and observances,<br> tamed, bearing their final body:<br> that’s who I declare a brahmin.\""},
 {t:"\"Like water from a lotus leaf,<br> like a mustard seed off a pin-point,<br> sensual pleasures slip off them:<br> that’s who I declare a brahmin.\""},
 {t:"\"They understand for themselves<br> the end of suffering in this life;<br> with burden put down, detached:<br> that’s who I declare a brahmin.\""},
 {t:"\"Deep in wisdom, intelligent,<br> expert in the path and what is not the path;<br> arrived at the highest goal:<br> that’s who I declare a brahmin.\""},
 {t:"\"Mixing with neither<br> householders nor the homeless;<br> a migrant with no bastion, few in wishes:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve laid aside violence<br> against creatures firm and frail;<br> not killing or making others kill:<br> that’s who I declare a brahmin.\""},
 {t:"\"Not fighting among those who fight,<br> quenched among those who have taken up arms,<br> not grasping among those who grasp:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve discarded greed and hate,<br> along with conceit and contempt,<br> like a mustard seed off the point of a pin:<br> that’s who I declare a brahmin.\""},
 {t:"\"The words they utter<br> are polished, informative, and true,<br> and don’t offend anyone:<br> that’s who I declare a brahmin.\""},
 {t:"\"They don’t steal anything in the world,<br> long or short,<br> fine or coarse, beautiful or ugly:<br> that’s who I declare a brahmin.\""},
 {t:"\"They have no hope<br> in this world or the next;<br> with no need for hope, detached:<br> that’s who I declare a brahmin.\""},
 {t:"\"They have no clinging,<br> knowledge has freed them of indecision,<br> they’ve arrived at the objective, freedom from death:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve escaped clinging<br> to both good and bad deeds;<br> sorrowless, stainless, pure:<br> that’s who I declare a brahmin.\""},
 {t:"\"Pure as the spotless moon,<br> clear and undisturbed,<br> they’ve ended relish for rebirth:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve got past this grueling swamp<br> of delusion, transmigration.<br> Meditating in stillness, free of indecision,<br> they have crossed over to the far shore.<br> They’re quenched by not grasping:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve given up sensual stimulations,<br> and have gone forth from lay life;<br> they’ve ended rebirth in the sensual realm:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve given up craving,<br> and have gone forth from lay life;<br> they’ve ended craving to be reborn:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve given up craving,<br> and have gone forth from lay life;<br> they’ve ended craving to be reborn:<br> that’s who I declare a brahmin.\""},
 {t:"\"They’ve thrown off the human yoke,<br> and slipped out of the heavenly yoke;<br> unyoked from all yokes:<br> that’s who I declare a brahmin.\""},
 {t:"\"Giving up desire and discontent,<br> they’re cooled and free of attachments;<br> a hero, master of the whole world:<br> that’s who I declare a brahmin.\""},
 {t:"\"They know the passing away<br> and rebirth of all beings;<br> unattached, holy, awakened:<br> that’s who I declare a brahmin.\""},
 {t:"\"Gods, centaurs, and humans<br> don’t know their destiny;<br> the perfected ones with defilements ended:<br> that’s who I declare a brahmin.\""},
 {t:"\"They have nothing before or after,<br> or even in between.<br> Having nothing, taking nothing:<br> that’s who I declare a brahmin.\""},
 {t:"\"Captain of the herd, excellent hero,<br> great seer and victor;<br> unstirred, washed, awakened:<br> that’s who I declare a brahmin.\""},
 {t:"\"One who knows their past lives,<br> sees heaven and places of loss,<br> and has attained the end of rebirth;<br> a sage of perfect insight<br> at the summit of spiritual perfection:<br> that’s who I declare a brahmin.\""},
];
const BADGES = [
    // --- Log Counts (Effort/Viriya) ---
    { id: 'log_1', icon: 'fas fa-fingerprint', color: '#a29bfe', title: 'Non-Self', desc: 'Complete your first meditation session', condition: (data) => data.logs.length >= 1 },
    { id: 'log_10', icon: 'fas fa-seedling', color: '#00b894', title: 'Dependent Co-arising', desc: 'Complete 10 meditation sessions', condition: (data) => data.logs.length >= 10 },
    { id: 'log_25', icon: 'fab fa-pagelines', color: '#55efc4', title: 'Wholesome Roots', desc: 'Complete 25 meditation sessions', condition: (data) => data.logs.length >= 25 },
    { id: 'log_50', icon: 'fas fa-leaf', color: '#fdcb6e', title: 'Kusala Dhamma', desc: 'Complete 50 meditation sessions', condition: (data) => data.logs.length >= 50 },
    { id: 'log_100', icon: 'fab fa-envira', color: '#00cec9', title: 'Wholesome Action', desc: 'Complete 100 meditation sessions', condition: (data) => data.logs.length >= 100 },
    { id: 'log_150', icon: 'fas fa-cloud-sun', color: '#ff7675', title: 'Detachment', desc: 'Complete 150 meditation sessions', condition: (data) => data.logs.length >= 150 },
    { id: 'log_200', icon: 'fas fa-rainbow', color: '#e056fd', title: 'Good Destination', desc: 'Complete 200 meditation sessions', condition: (data) => data.logs.length >= 200 },
    { id: 'log_250', icon: 'fas fa-mountain', color: '#48dbfb', title: 'Snow Mountain', desc: 'Complete 250 meditation sessions', condition: (data) => data.logs.length >= 250 },
    { id: 'log_300', icon: 'fas fa-gopuram', color: '#fd79a8', title: 'Leading Onwards', desc: 'Complete 300 meditation sessions', condition: (data) => data.logs.length >= 300 },
    { id: 'log_350', icon: 'fas fa-vihara', color: '#ff9f43', title: 'Vihara', desc: 'Complete 350 meditation sessions', condition: (data) => data.logs.length >= 350 },
    { id: 'log_400', icon: 'fas fa-archway', color: '#fab1a0', title: 'Deathless Gate', desc: 'Complete 400 meditation sessions', condition: (data) => data.logs.length >= 400 },
    { id: 'log_450', icon: 'fas fa-kaaba', color: '#74b9ff', title: 'The Pillar', desc: 'Complete 450 meditation sessions', condition: (data) => data.logs.length >= 450 },
    { id: 'log_500', icon: 'fas fa-monument', color: '#ffbe76', title: 'The Stupa', desc: 'Complete 500 meditation sessions', condition: (data) => data.logs.length >= 500 },
    { id: 'log_600', icon: 'fab fa-fort-awesome', color: '#a29bfe', title: 'Dhamma Fortress', desc: 'Complete 600 meditation sessions', condition: (data) => data.logs.length >= 600 },
    { id: 'log_700', icon: 'fa-dungeon', color: '#6ab04c', title: 'Solitude', desc: 'Complete 700 meditation sessions', condition: (data) => data.logs.length >= 700 },
    { id: 'log_800', icon: 'fab fa-d-and-d', color: '#eb4d4b', title: 'Naga', desc: 'Complete 800 meditation sessions', condition: (data) => data.logs.length >= 800 },
    { id: 'log_1000', icon: 'fas fa-dharmachakra', color: '#f9ca24', title: 'Wheel Turner', desc: 'Complete 1000 meditation sessions', condition: (data) => data.logs.length >= 1000 },

    // --- Streaks (Consistency) ---
    { id: 'streak_3', icon: 'fas fa-shoe-prints', color: '#bdc3c7', title: 'Walking Path', desc: 'Practice for 3 consecutive days', condition: (data) => data.streak >= 3 },
    { id: 'streak_5', icon: 'fas fa-bridge-water', color: '#48dbfb', title: 'Noble Quest', desc: 'Practice for 5 consecutive days', condition: (data) => data.streak >= 5 },
    { id: 'streak_7', icon: 'fas fa-clover', color: '#2ecc71', title: 'Blessings', desc: 'Practice for 7 consecutive days', condition: (data) => data.streak >= 7 },
    { id: 'streak_14', icon: 'fas fa-certificate', color: '#f1c40f', title: 'Virtue', desc: 'Practice for 14 consecutive days', condition: (data) => data.streak >= 14 },
    { id: 'streak_21', icon: 'fas fa-book-open-reader', color: '#e17055', title: 'Learned', desc: 'Practice for 21 consecutive days', condition: (data) => data.streak >= 21 },
    { id: 'streak_30', icon: 'fab fa-sketch', color: '#ff9f43', title: 'Willpower', desc: 'Practice for 30 consecutive days', condition: (data) => data.streak >= 30 },
    { id: 'streak_49', icon: 'fab fa-jira', color: '#54a0ff', title: 'Satipaṭṭhāna', desc: 'Practice for 49 consecutive days', condition: (data) => data.streak >= 49 },
    { id: 'streak_60', icon: 'fas fa-link', color: '#a29bfe', title: 'The Cause', desc: 'Practice for 60 consecutive days', condition: (data) => data.streak >= 60 },
    { id: 'streak_90', icon: 'fab fa-brave', color: '#ff6b6b', title: 'Great Hero', desc: 'Practice for 90 consecutive days', condition: (data) => data.streak >= 90 },
    { id: 'streak_100', icon: 'fab fa-brave-reverse', color: '#d63031', title: 'Lion’s Roar', desc: 'Practice for 100 consecutive days', condition: (data) => data.streak >= 100 },
    { id: 'streak_180', icon: 'fab fa-wolf-pack-battalion', color: '#81ecec', title: 'The Great Tamer', desc: 'Practice for 180 consecutive days', condition: (data) => data.streak >= 180 },
    { id: 'streak_365', icon: 'fas fa-infinity', color: '#0984e3', title: 'Timeless', desc: 'Practice for 365 consecutive days', condition: (data) => data.streak >= 365 },

    // --- Time Accumulation ---
    { id: 'time_1h', icon: 'fas fa-hourglass-empty', color: '#f1c40f', title: 'Here & Now', desc: 'Accumulate 1 hour of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 60 },
    { id: 'time_5h', icon: 'fas fa-circle-notch', color: '#ffbe76', title: 'Emptiness', desc: 'Accumulate 5 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 300 },
    { id: 'time_10h', icon: 'fas fa-record-vinyl', color: '#badc58', title: 'Mindfulness', desc: 'Accumulate 10 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 600 },
    { id: 'time_20h', icon: 'fab fa-files-pinwheel', color: '#686de0', title: 'Right Action', desc: 'Accumulate 20 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 1200 },
    { id: 'time_30h', icon: 'fas fa-snowflake', color: '#48dbfb', title: 'Stillness', desc: 'Accumulate 30 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 1800 },
    { id: 'time_50h', icon: 'fas fa-water', color: '#0abde3', title: 'Stream Entry', desc: 'Accumulate 50 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 3000 },
    { id: 'time_80h', icon: 'fas fa-wind', color: '#c7ecee', title: 'The Breath', desc: 'Accumulate 80 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 4800 },
    { id: 'time_100h', icon: 'fas fa-fire-burner', color: '#ee5253', title: 'Ardor', desc: 'Accumulate 100 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 6000 },
    { id: 'time_250h', icon: 'fas fa-burn', color: '#f368e0', title: 'Zeal', desc: 'Accumulate 150 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 9000 },
    { id: 'time_150h', icon: 'fas fa-fire', color: '#ff6b6b', title: 'Wisdom Fire', desc: 'Accumulate 200 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 12000 },
    { id: 'time_200h', icon: 'fas fa-fire-flame-curved', color: '#ff9f43', title: 'Jhana Fire', desc: 'Accumulate 250 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 15000 },
    { id: 'time_300h', icon: 'fas fa-bolt', color: '#feca57', title: 'Wisdom Root', desc: 'Accumulate 300 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 18000 },
    { id: 'time_400h', icon: 'fas fa-bolt-lightning', color: '#ff9ff3', title: 'Wisdom Power', desc: 'Accumulate 400 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 24000 },
    { id: 'time_500h', icon: 'fas fa-sun', color: '#ffaf40', title: 'Clear Seeing', desc: 'Accumulate 500 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 30000 },
    { id: 'time_800h', icon: 'fas fa-moon', color: '#dfe6e9', title: 'Auspicious', desc: 'Accumulate 800 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 48000 },
    { id: 'time_1000h', icon: 'fab fa-skyatlas', color: '#74b9ff', title: 'The Void', desc: 'Accumulate 1000 hours of practice', condition: (data) => data.logs.reduce((s, l) => s + l.minutes, 0) >= 60000 },

    // --- Session Length ---
    { id: 'sit_15', icon: 'fab fa-deskpro', color: '#48dbfb', title: 'Elephant King', desc: 'Session length ≥ 15 minutes', condition: (data) => data.logs.some(l => l.minutes >= 15) },
    { id: 'sit_30', icon: 'fab fa-medapps', color: '#feca57', title: 'The Lamp', desc: 'Session length ≥ 30 minutes', condition: (data) => data.logs.some(l => l.minutes >= 30) },
    { id: 'sit_45', icon: 'fas fa-hand-holding-hand', color: '#cd84f1', title: 'Compassion', desc: 'Session length ≥ 45 minutes', condition: (data) => data.logs.some(l => l.minutes >= 45) },
    { id: 'sit_60', icon: 'fas fa-gem', color: '#7d5fff', title: 'Composure', desc: 'Session length ≥ 60 minutes', condition: (data) => data.logs.some(l => l.minutes >= 60) },
    { id: 'sit_90', icon: 'fab fa-ethereum', color: '#dfe6e9', title: 'Joyful Mind', desc: 'Session length ≥ 90 minutes', condition: (data) => data.logs.some(l => l.minutes >= 90) },
    { id: 'sit_120', icon: 'fas fa-anchor', color: '#ff9ff3', title: 'Dhamma Pillar', desc: 'Session length ≥ 2 hours', condition: (data) => data.logs.some(l => l.minutes >= 120) },
    { id: 'sit_180', icon: 'fas fa-balance-scale', color: '#00d2d3', title: 'Letting Go', desc: 'Session length ≥ 3 hours', condition: (data) => data.logs.some(l => l.minutes >= 180) },
    { id: 'sit_240', icon: 'fab fa-jedi-order', color: '#d980fa', title: 'Samadhi', desc: 'Session length ≥ 4 hours', condition: (data) => data.logs.some(l => l.minutes >= 240) },

    // --- Mindfulness Counts ---
    { id: 'mind_100', icon: 'fas fa-bullseye', color: '#ff7675', title: 'One-Pointedness', desc: 'Recorded 100 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 100 },
    { id: 'mind_500', icon: 'fas fa-circle-half-stroke', color: '#dfe6e9', title: 'Purification', desc: 'Recorded 500 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 500 },
    { id: 'mind_1k', icon: 'fab fa-superpowers', color: '#f1c40f', title: 'Contentment', desc: 'Recorded 1,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 1000 },
    { id: 'mind_2k', icon: 'fab fa-servicestack', color: '#74b9ff', title: 'Crossing the Flood', desc: 'Recorded 2,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 2000 },
    { id: 'mind_3k', icon: 'fas fa-layer-group', color: '#a29bfe', title: 'Five Aggregates', desc: 'Recorded 3,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 3000 },
    { id: 'mind_4k', icon: 'fab fa-schlix', color: '#d980fa', title: 'Right Speech', desc: 'Recorded 4,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 4000 },
    { id: 'mind_5k', icon: 'fab fa-modx', color: '#81ecec', title: 'Gratitude', desc: 'Recorded 5,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 5000 },
    { id: 'mind_6k', icon: 'fab fa-fulcrum', color: '#55efc4', title: 'The Recluse', desc: 'Recorded 6,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 6000 },
    { id: 'mind_7k', icon: 'fab fa-first-order', color: '#fab1a0', title: 'Sense Bases', desc: 'Recorded 7,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 7000 },
    { id: 'mind_8k', icon: 'fab fa-first-order-alt', color: '#e17055', title: 'Conscience', desc: 'Recorded 8,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 8000 },
    { id: 'mind_10k', icon: 'fab fa-medrt', color: '#eb4d4b', title: 'Offering', desc: 'Recorded 10,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 10000 },
    { id: 'mind_15k', icon: 'fab fa-studiovinari', color: '#00cec9', title: 'Dispassion', desc: 'Recorded 15,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 15000 },
    { id: 'mind_20k', icon: 'fab fa-connectdevelop', color: '#74b9ff', title: 'Investigation', desc: 'Recorded 20,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 20000 },
    { id: 'mind_25k', icon: 'fab fa-linktree', color: '#00b894', title: 'Sorrowless', desc: 'Recorded 25,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 25000 },
    { id: 'mind_30k', icon: 'fas fa-hexagon-nodes', color: '#e056fd', title: 'Insight', desc: 'Recorded 30,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 30000 },
    { id: 'mind_40k', icon: 'fab fa-slack', color: '#ff7675', title: 'Virtue Fragrance', desc: 'Recorded 40,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 40000 },
    { id: 'mind_50k', icon: 'fab fa-hornbill', color: '#feca57', title: 'Bliss', desc: 'Recorded 50,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 50000 },
    { id: 'mind_80k', icon: 'fas fa-dragon', color: '#d63031', title: 'Mastery', desc: 'Recorded 80,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 80000 },
    { id: 'mind_100k', icon: 'fas fa-om', color: '#f9ca24', title: 'Suchness', desc: 'Recorded 100,000 mindfulness', condition: (data) => data.logs.reduce((s, l) => s + (l.count||0), 0) >= 100000 },

    // --- DAILY MINDFULNESS (Intensity) ---
    { id: 'mindf_200', icon: 'fab fa-linode', color: '#48dbfb', title: 'Middle Way', desc: 'Recorded ≥ 600 mindfulness in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => { const c = l.count || (l.touches ? l.touches.length : 0); daily[l.date] = (daily[l.date]||0) + c; }); return Object.values(daily).some(c => c >= 600); }},
    { id: 'mindf_400', icon: 'fab fa-shoelace', color: '#a29bfe', title: 'Patience', desc: 'Recorded ≥ 1200 mindfulness in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => { const c = l.count || (l.touches ? l.touches.length : 0); daily[l.date] = (daily[l.date]||0) + c; }); return Object.values(daily).some(c => c >= 1200); }},
    { id: 'mindf_600', icon: 'fas fa-people-roof', color: '#f1c40f', title: 'Harmony', desc: 'Recorded ≥ 2400 mindfulness in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => { const c = l.count || (l.touches ? l.touches.length : 0); daily[l.date] = (daily[l.date]||0) + c; }); return Object.values(daily).some(c => c >= 2400); }},
    { id: 'mindf_1000', icon: 'fas fa-user-shield', color: '#686de0', title: 'Self-Control', desc: 'Recorded ≥ 3600 mindfulness in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => { const c = l.count || (l.touches ? l.touches.length : 0); daily[l.date] = (daily[l.date]||0) + c; }); return Object.values(daily).some(c => c >= 3600); }},

    // --- QUALITY (Qualities/Phẩm Chất) ---
    { id: 'focus_5_min', icon: 'fas fa-feather-pointed', color: '#81ecec', title: 'Tranquillity', desc: 'Achieved ≥ 5 mindfulness/minute (session ≥ 20m)', condition: (data) => data.logs.some(l => l.minutes >= 20 && (l.count/l.minutes) >= 5) },
    { id: 'focus_6_min', icon: 'fas fa-shield-alt', color: '#badc58', title: 'Guardian', desc: 'Achieved ≥ 6 mindfulness/minute (session ≥ 20m)', condition: (data) => data.logs.some(l => l.minutes >= 20 && (l.count/l.minutes) >= 6) },
    { id: 'focus_7_min', icon: 'fas fa-bahai', color: '#ffeaa7', title: 'Awakening', desc: 'Achieved ≥ 7 mindfulness/minute (session ≥ 20m)', condition: (data) => data.logs.some(l => l.minutes >= 20 && (l.count/l.minutes) >= 7) },
    { id: 'focus_8_min', icon: 'fas fa-life-ring', color: '#fab1a0', title: 'Eightfold Path', desc: 'Achieved ≥ 8 mindfulness/minute (session ≥ 20m)', condition: (data) => data.logs.some(l => l.minutes >= 20 && (l.count/l.minutes) >= 8) },
    { id: 'focus_9_min', icon: 'fab fa-debian', color: '#e17055', title: 'Kamma', desc: 'Achieved ≥ 9 mindfulness/minute (session ≥ 20m)', condition: (data) => data.logs.some(l => l.minutes >= 20 && (l.count/l.minutes) >= 9) },
    { id: 'focus_10_min', icon: 'fas fa-hands-holding-circle', color: '#ff7675', title: 'Generosity', desc: 'Achieved ≥ 10 mindfulness/minute (session ≥ 20m)', condition: (data) => data.logs.some(l => l.minutes >= 20 && (l.count/l.minutes) >= 10) },
    { id: 'focus_12_min', icon: 'fas fa-ranking-star', color: '#f9ca24', title: 'Sublime Dhamma', desc: 'Achieved ≥ 12 mindfulness/minute (session ≥ 20m)', condition: (data) => data.logs.some(l => l.minutes >= 20 && (l.count/l.minutes) >= 12) },

    // --- FOCUS SCORES (Samadhi Levels) ---
    { id: 'sfocus_1_5', icon: 'fab fa-free-code-camp', color: '#ff7979', title: 'Right Effort', desc: 'Avg Focus ≥ 1.5 in session ≤ 20m', condition: (data) => data.logs.some(l => { if (l.minutes > 20 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if(proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 1.5; }) },
    { id: 'sfocus_2_0', icon: 'fab fa-react', color: '#7ed6df', title: 'Name & Form', desc: 'Avg Focus ≥ 2 in session ≤ 20m', condition: (data) => data.logs.some(l => { if (l.minutes > 20 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if(proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 2.0; }) },
    { id: 'sfocus_2_5', icon: 'fa-meteor', color: '#badc58', title: 'Effort', desc: 'Avg Focus ≥ 2.5 in session ≤ 20m', condition: (data) => data.logs.some(l => { if (l.minutes > 20 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if(proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 2.5; }) },
    { id: 'sfocus_3_0', icon: 'fas fa-jedi', color: '#e056fd', title: 'The Warrior', desc: 'Avg Focus ≥ 3 in session ≤ 20m', condition: (data) => data.logs.some(l => { if (l.minutes > 20 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if(proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 3.0; }) },
    { id: 'sfocus_3_5', icon: 'fas fa-hanukiah', color: '#f9ca24', title: 'Heedfulness', desc: 'Avg Focus ≥ 3.5 in session ≤ 20m', condition: (data) => data.logs.some(l => { if (l.minutes > 20 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if (proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 3.5; }) },

    { id: 'sfocus_2', icon: 'fas fa-globe-asia', color: '#22a6b3', title: 'The Island', desc: 'Avg Focus ≥ 2 in session ≥ 45m', condition: (data) => data.logs.some(l => { if (l.minutes < 45 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if(proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 2.0; }) },
    { id: 'sfocus_2_5', icon: 'fab fa-drupal', color: '#2ed573', title: 'Cultivation', desc: 'Avg Focus ≥ 2.5 in session ≥ 45m', condition: (data) => data.logs.some(l => { if (l.minutes < 45 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if(proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 2.5; }) },
    { id: 'sfocus_3', icon: 'fa-spa', color: '#6c5ce7', title: 'Quietude', desc: 'Avg Focus ≥ 3.0 in session ≥ 45m', condition: (data) => data.logs.some(l => { if (l.minutes < 45 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if(proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 3.0; }) },
    { id: 'sfocus_3_5', icon: 'fas fa-dove', color: '#dfe6e9', title: 'Stainless', desc: 'Avg Focus ≥ 3.5 in session ≥ 45m', condition: (data) => data.logs.some(l => { if (l.minutes < 45 || !l.touches) return false; const proT = l.touches.filter(t => t.v); if(proT.length < 5) return false; const score = proT.reduce((s, t) => s + (5-t.v), 0) / proT.length; return score >= 3.5; }) },

    { id: 'note_long', icon: 'fa-pen-nib', color: '#ff9f43', title: 'The Learner', desc: 'Write a note longer than 50 chars', condition: (data) => data.logs.some(l => l.notes && l.notes.length > 50) },
    { id: 'note_many', icon: 'fa-scroll', color: '#a29bfe', title: 'Dhamma Heir', desc: '50 sessions with notes ≥ 50 chars', condition: (data) => data.logs.filter(l => l.notes && l.notes.length > 100).length >= 50 },
    
    // --- MISC / SPECIAL ---
    { id: 'goal-early_4am', icon: 'fas fa-star-half-stroke', color: '#ff6b6b', title: 'Morning Star', desc: 'Complete a session before 4:00 AM', condition: (data) => data.logs.some(l => new Date(l.timestamp).getHours() < 4) },
    { id: 'goal-early_5am', icon: 'fab fa-tidal', color: '#7ed6df', title: 'Four Noble Truths', desc: 'Complete a session before 5:00 AM', condition: (data) => data.logs.some(l => new Date(l.timestamp).getHours() < 5) },
    { id: 'goal-early_3d', icon: 'fas fa-star', color: '#ffbe76', title: 'Aspiration', desc: '3 consecutive days meditating before 5:00 AM', condition: (data) => { const earlyLogs = data.logs.filter(l => new Date(l.timestamp).getHours() < 5).map(l => l.date); const uniqueDays = [...new Set(earlyLogs)].sort(); let streak = 0; for(let i=0; i<uniqueDays.length-1; i++) { const d1 = new Date(uniqueDays[i]); const d2 = new Date(uniqueDays[i+1]); if ((d2-d1) <= 86400000) streak++; else streak = 0; if(streak >= 2) return true; } return false; }},
    { id: 'goal-early_7d', icon: 'fa-ribbon', color: '#2ecc71', title: 'Ultimate Goal', desc: '7 consecutive days meditating before 5:00 AM', condition: (data) => { const earlyLogs = data.logs.filter(l => new Date(l.timestamp).getHours() < 5).map(l => l.date); const uniqueDays = [...new Set(earlyLogs)].sort(); let streak = 0; for(let i=0; i<uniqueDays.length-1; i++) { const d1 = new Date(uniqueDays[i]); const d2 = new Date(uniqueDays[i+1]); if ((d2-d1) <= 86400000) streak++; else streak = 0; if(streak >= 6) return true; } return false; }},
    { id: 'lunch', icon: 'fab fa-viadeo', color: '#badc58', title: 'Fruit of Wisdom', desc: 'Meditate during lunch break (11h-13h)', condition: (data) => data.logs.some(l => { const h = new Date(l.timestamp).getHours(); return h >= 11 && h <= 13; }) },
    { id: 'goal-evening', icon: 'fas fa-cloud-showers-heavy', color: '#0984e3', title: 'Rain Retreat', desc: 'Meditate in the evening (17h-19h)', condition: (data) => data.logs.some(l => { const h = new Date(l.timestamp).getHours(); return h >= 17 && h <= 19; }) },
    { id: 'goal-night', icon: 'fab fa-squarespace', color: '#a29bfe', title: 'Causality', desc: 'Meditate after 22:00 PM', condition: (data) => data.logs.some(l => new Date(l.timestamp).getHours() >= 22) },
    { id: 'goal_100', icon: 'fab fa-think-peaks', color: '#f9ca24', title: 'Seclusion', desc: 'Achieve 100% of a meditation goal', condition: (data) => data.goals.some(g => { const target = g.type === 'meditation' ? g.totalMindfulness : g.totalMinutes; return g.lifetimeTargetMinutes > 0 && target >= g.lifetimeTargetMinutes; }) },
    { id: 'goal_80', icon: 'fas fa-heart', color: '#ff7675', title: 'Loving-Kindness', desc: 'Achieve 80% of a meditation goal', condition: (data) => data.goals.some(g => { const target = g.type === 'meditation' ? g.totalMindfulness : g.totalMinutes; return g.lifetimeTargetMinutes > 0 && target >= (g.lifetimeTargetMinutes / 2); }) },
    
    { id: 'daily_volume_30p', icon: 'fab fa-canadian-maple-leaf', color: '#e58e26', title: 'Impermanence', desc: 'Total meditation ≥ 30 minutes in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => daily[l.date] = (daily[l.date]||0) + l.minutes); return Object.values(daily).some(m => m >= 30); }},
    { id: 'daily_volume_1h', icon: 'fab fa-phoenix-framework', color: '#fa983a', title: 'Restraint', desc: 'Total meditation ≥ 1 hour in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => daily[l.date] = (daily[l.date]||0) + l.minutes); return Object.values(daily).some(m => m >= 60); }},
    { id: 'daily_volume_2h', icon: 'fab fa-phoenix-squadron', color: '#eb2f06', title: 'The Deathless', desc: 'Total meditation ≥ 2 hours in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => daily[l.date] = (daily[l.date]||0) + l.minutes); return Object.values(daily).some(m => m >= 120); }},
    { id: 'daily_volume_3h', icon: 'fab fa-gripfire', color: '#e55039', title: 'Diligence', desc: 'Total meditation ≥ 3 hours in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => daily[l.date] = (daily[l.date]||0) + l.minutes); return Object.values(daily).some(m => m >= 180); }},
    { id: 'daily_volume_4h', icon: 'fab fa-rebel', color: '#74b9ff', title: 'Non-Violence', desc: 'Total meditation ≥ 4 hours in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => daily[l.date] = (daily[l.date]||0) + l.minutes); return Object.values(daily).some(m => m >= 240); }},
    { id: 'daily_volume_5h', icon: 'fab fa-sith', color: '#badc58', title: 'Wakefulness', desc: 'Total meditation ≥ 5 hours in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => daily[l.date] = (daily[l.date]||0) + l.minutes); return Object.values(daily).some(m => m >= 300); }},
    { id: 'daily_volume_8h', icon: 'fab fa-battle-net', color: '#6a89cc', title: 'Wise Attention', desc: 'Total meditation ≥ 8 hours in a day', condition: (data) => { const daily = {}; data.logs.forEach(l => daily[l.date] = (daily[l.date]||0) + l.minutes); return Object.values(daily).some(m => m >= 480); }},
    { id: 'freq_3_day', icon: 'fas fa-users', color: '#f0932b', title: 'Sangha', desc: 'Meditate 3 times in one day', condition: (data) => { const counts = {}; data.logs.forEach(l => counts[l.date] = (counts[l.date]||0)+1); return Object.values(counts).some(c => c >= 3); }},
    { id: 'freq_5_day', icon: 'fas fa-hand-sparkles', color: '#48dbfb', title: 'Five Precepts', desc: 'Meditate 5 times in one day', condition: (data) => { const counts = {}; data.logs.forEach(l => counts[l.date] = (counts[l.date]||0)+1); return Object.values(counts).some(c => c >= 5); }},
    { id: 'freq_10_day', icon: 'fas fa-hands-praying', color: '#ffbe76', title: 'Pure Faith', desc: 'Meditate 10 times in one day', condition: (data) => { const counts = {}; data.logs.forEach(l => counts[l.date] = (counts[l.date]||0)+1); return Object.values(counts).some(c => c >= 5); }},
    { id: 'dedicated_day', icon: 'fa-landmark', color: '#2ecc71', title: 'Three Jewels', desc: 'Complete 3 separate sessions ≥ 60m in a day', condition: (data) => { const goodLogs = data.logs.filter(l => l.minutes >= 60); const counts = {}; goodLogs.forEach(l => counts[l.date] = (counts[l.date]||0)+1); return Object.values(counts).some(c => c >= 3); }},
    { id: 'quick_fix', icon: 'fas fa-user-plus', color: '#f6e58d', title: 'Self-Victory', desc: 'Complete 10 short sessions (≤ 10m)', condition: (data) => data.logs.filter(l => l.minutes < 10).length >= 10 },
    { id: 'quick_fix2', icon: 'fa-fan', color: '#a29bfe', title: 'Disenchantment', desc: 'Complete 30 short sessions (≤ 10m)', condition: (data) => data.logs.filter(l => l.minutes < 10).length >= 30 },
    { id: 'long_haul', icon: 'fa-tree', color: '#badc58', title: 'Perseverance', desc: 'Complete 10 long sessions (≥ 60m)', condition: (data) => data.logs.filter(l => l.minutes >= 60).length >= 10 },
    { id: 'long_haul2', icon: 'fab fa-watchman-monitoring', color: '#ff6b6b', title: 'Lighthouse', desc: 'Complete 20 long sessions (≥ 60m)', condition: (data) => data.logs.filter(l => l.minutes >= 60).length >= 20 },
    { id: 'long_haul3', icon: 'fab fa-codepen', color: '#55efc4', title: 'Non-Ill Will', desc: 'Complete 50 long sessions (≥ 60m)', condition: (data) => data.logs.filter(l => l.minutes >= 60).length >= 50 },
    { id: 'overachiever', icon: 'fa-sailboat', color: '#74b9ff', title: 'Virtuous', desc: 'Complete 200% of daily goal', condition: (data) => { return data.goals.some(g => { if(!g.dailyMinMedTarget) return false; const todayStr = new Date().toISOString().split('T')[0]; const todayVal = data.logs.filter(l => l.goalId === g.id && l.date === todayStr).reduce((s,l)=>s+(g.type==='meditation'? (l.count||0) : l.minutes), 0); return todayVal >= (g.dailyMinMedTarget * 2); }); }},
];
const DB_CONFIG = {
    name: 'HanhGiaDB',
    version: 2, // <--- UPDATE VERSION TO 2
    stores: {
        goals: 'id',
        logs: 'timestamp',
        meta: 'key'
    }
};

const dbHelper = {
    db: null,
    
    open() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);
            
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                const tx = e.target.transaction;

                // Create stores if they don't exist
                if (!db.objectStoreNames.contains('goals')) db.createObjectStore('goals', { keyPath: 'id' });
                if (!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
                
                let logStore;
                if (!db.objectStoreNames.contains('logs')) {
                    logStore = db.createObjectStore('logs', { keyPath: 'timestamp' });
                } else {
                    logStore = tx.objectStore('logs');
                }

                // --- NEW: Create Index for fast deletion ---
                if (!logStore.indexNames.contains('goalId')) {
                    logStore.createIndex('goalId', 'goalId', { unique: false });
                }
            };

            req.onsuccess = (e) => {
                this.db = e.target.result;
                resolve(this.db);
            };
            req.onerror = (e) => reject("DB Error: " + e.target.error);
        });
    },

    async deleteLog(timestamp) {
        if (!this.db) await this.open();
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(['logs'], 'readwrite');
            const store = tx.objectStore('logs');
            store.delete(Number(timestamp)); 
            tx.oncomplete = () => resolve();
            tx.onerror = (e) => reject(e);
        });
    },

    // --- OPTIMIZED DELETE FUNCTION ---
    async deleteGoalData(goalId) {
        if (!this.db) await this.open();
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(['goals', 'logs'], 'readwrite');
            
            // 1. Delete the Goal itself
            const goalStore = tx.objectStore('goals');
            goalStore.delete(goalId);

            // 2. Delete related Logs using the INDEX (Instant)
            const logStore = tx.objectStore('logs');
            
            try {
                // Use the index we created in version 2
                const index = logStore.index('goalId');
                const req = index.openKeyCursor(IDBKeyRange.only(goalId));

                req.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        logStore.delete(cursor.primaryKey); // Delete by specific key
                        cursor.continue();
                    }
                };
            } catch (err) {
                // Fallback for safety if index is missing (rare)
                console.warn("Index missing, falling back to slow delete", err);
                const req = logStore.openCursor();
                req.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        if (cursor.value.goalId === goalId) cursor.delete();
                        cursor.continue();
                    }
                };
            }

            tx.oncomplete = () => resolve();
            tx.onerror = (e) => reject(e);
        });
    },
    // ------------------------------------------

    async saveAll(data) {
        if (!this.db) await this.open();
        
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(['goals', 'logs', 'meta'], 'readwrite');
            
            const goalStore = tx.objectStore('goals');
            data.goals.forEach(g => goalStore.put(g));
            
            const logStore = tx.objectStore('logs');
            data.logs.forEach(l => logStore.put(l));
            
            const metaStore = tx.objectStore('meta');
            metaStore.put({ key: 'xp', value: data.xp });
            metaStore.put({ key: 'streak', value: data.streak });
            metaStore.put({ key: 'achievements', value: data.achievements });
            metaStore.put({ key: 'medSettings', value: data.medSettings });
            metaStore.put({ key: 'activeBadge', value: data.activeBadge });
            tx.oncomplete = () => resolve();
            tx.onerror = (e) => reject(e);
        });
    },

    async loadAll() {
        if (!this.db) await this.open();

        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(['goals', 'logs', 'meta'], 'readonly');
            const data = { goals: [], logs: [], xp: 0, streak: 0, achievements: [], medSettings: {} };
            
            const getAll = (storeName) => {
                return new Promise((res, rej) => {
                    const req = tx.objectStore(storeName).getAll();
                    req.onsuccess = () => res(req.result);
                    req.onerror = () => rej(req.error);
                });
            };

            Promise.all([getAll('goals'), getAll('logs'), getAll('meta')])
                .then(([goals, logs, metaItems]) => {
                    data.goals = goals || [];
                    data.logs = logs || [];
                    
                    metaItems.forEach(item => {
                        if (item.key === 'xp') data.xp = item.value;
                        if (item.key === 'streak') data.streak = item.value;
                        if (item.key === 'achievements') data.achievements = item.value;
                        if (item.key === 'medSettings') data.medSettings = item.value;
						if (item.key === 'activeBadge') data.activeBadge = item.value;
                    });
                    resolve(data);
                })
                .catch(reject);
        });
    },

    async isEmpty() {
        if (!this.db) await this.open();
        return new Promise(resolve => {
            const tx = this.db.transaction(['meta'], 'readonly');
            const req = tx.objectStore('meta').count();
            req.onsuccess = () => resolve(req.result === 0);
        });
    }
};
        Chart.defaults.color = '#9ca3af';
        Chart.defaults.borderColor = '#374151';

        class GoalTracker {
            constructor() {
                // We define the structure but don't load data yet
                this.data = {
                    goals: [],
                    logs: [],
                    xp: 0,
                    streak: 0,
                    achievements: [],
                    medSettings: { mode: 'tap', holdDuration: 500, tapRequired: 1, vibration: true }
                };

                // Other initializations remain the same
                this.tapState = { count: 0, lastTapTime: 0, timer: null };
                this.timers = {}; 
                this.today = new Date();
                this.currentMonth = new Date(this.today.getFullYear(), this.today.getMonth(), 1); 
                this.currentWeekStart = this.getStartOfWeek(this.today); 
                this.charts = { weekly: null, breakdown: null, monthly: null, dayChart: null, session: null };
                this.reportMode = 'time';
                this.meditationState = {
                    active: false, paused: false, goalId: null, count: 0,
                    startTime: null, timerRef: null, remainingSeconds: 0,
                    totalDurationSeconds: 0, touches: [] 
                };
                this.currentViewDate = null; 
                this.dayChartMode = 'time'; 
                
                // Define quick tags...
                this.QUICK_TAGS = [

    'Awake', 'Calm/Still', 'Peaceful', 'Joyful', 
    'Tranquil', 'Relaxed', 'Clear/Lucid', 'Spacious', 'Deep Concentration', 
    'Letting Go', 'Grateful', 'Gentle', 'Inner Light',

    'Wandering Mind', 'Delusion', 'Restlessness', 'Dullness', 'Sleepy', 
    'Drowsiness', 'Scattered Mind', 'Anxious', 'Anger/Irritation', 'Cravings',
    'Doubt', 'Overthinking', 'Reminiscing', 'Stressed',

    'Back Pain', 'Numb Legs', 'Itchy', 'Neck Pain', 'Hot', 'Cold'
];

                // CALL THE ASYNC INIT
                this.init();
            }
			
			 // Tìm hàm init() và thay thế nội dung đoạn đầu như sau:
async init() {
    try {
        await dbHelper.open();

        const dbData = await dbHelper.loadAll();
        if (dbData) {
            this.data = { ...this.data, ...dbData };
        }

        // --- THAY ĐỔI: Cấu hình mặc định mới ---
        if (!this.data.medSettings) this.data.medSettings = {};
        
        // Luôn luôn ép về chế độ thống nhất
        this.data.medSettings.mode = 'unified'; 
        
        // Đảm bảo các chỉ số khác có giá trị mặc định
        if (!this.data.medSettings.holdDuration) this.data.medSettings.holdDuration = 500;
        if (typeof this.data.medSettings.vibration === 'undefined') this.data.medSettings.vibration = true;
        if (typeof this.data.medSettings.confirmMode === 'undefined') this.data.medSettings.confirmMode = false;
        if (typeof this.data.medSettings.confirmProbability === 'undefined') this.data.medSettings.confirmProbability = 100;
        
        // Xóa các thuộc tính cũ không dùng nữa để nhẹ data
        delete this.data.medSettings.proMode;
        delete this.data.medSettings.tapRequired;
        // ---------------------------------------

        this.data.goals.forEach(goal => {
            if (!goal.type) goal.type = 'standard';
            if (!goal.sessionTargetSeconds) goal.sessionTargetSeconds = 0;
            if (!goal.remainingSeconds) goal.remainingSeconds = 0;
            if (typeof goal.dailyTargetMinutes === 'undefined') goal.dailyTargetMinutes = 30;
            if (goal.type === 'meditation' && !goal.currentMindfulness) goal.currentMindfulness = 0;
            if (goal.type === 'meditation' && !goal.totalMindfulness) goal.totalMindfulness = 0;
        });

        this.analyticsGoalFilter = localStorage.getItem('anaGoalFilter') || 'all';
        this.renderDate();
        this.renderGoals();
        this.updateStats();
        this.checkAchievements();
        this.renderCalendar();
        this.loadActiveBadge();
        setInterval(() => this.updateTimerUI(), 1000);
        this.setupMeditationListeners();
        this.noSleepAudio = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=');
        this.noSleepAudio.loop = true;
        this.noSleepAudio.volume = 0.01;

    } catch (err) {
        console.error("Error loading data!", err);
        this.showToast("Error loading data!");
    }

    if (!localStorage.getItem('intro_seen')) {
        this.openIntroModal();
    }
}
hexToRgba(hex, alpha) {
    let c;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
        c = hex.substring(1).split('');
        if (c.length === 3) {
            c = [c[0], c[0], c[1], c[1], c[2], c[2]];
        }
        c = '0x' + c.join('');
        return 'rgba(' + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',') + ',' + alpha + ')';
    }
    return `rgba(156, 163, 175, ${alpha})`; // Fallback gray
}
setupMeditationListeners() {
    const medOverlay = document.getElementById('meditation-overlay');
    const counterEl = document.getElementById('med-counter');
    let pressTimer = null;
    
    if (medOverlay) {
         medOverlay.addEventListener('pointerdown', (e) => {
            if (e.target.closest('.med-controls') || e.target.closest('.modal')) return;
            e.preventDefault(); 
            
            const settings = this.data.medSettings;
            // Luôn dùng logic holdDuration
            this.holdTriggered = false; 
            
            counterEl.style.transform = "scale(0.9)";
            counterEl.style.transition = "transform 0.1s";
            
            // Logic Giữ (Hold) -> Kích hoạt mức Tốt (Level 2) hoặc Cao (Level 1 - xử lý bên trong trigger)
            pressTimer = setTimeout(() => {
                this.triggerAwarenessSuccess(); // <--- GỌI HÀM MỚI
                this.holdTriggered = true;
                pressTimer = null;
            }, settings.holdDuration || 500);
        });

        const handleRelease = (e) => {
            if (e.target.closest('.med-controls')) return;
            
            if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
            counterEl.style.transform = "scale(1)";
            
            // Nếu đã kích hoạt Hold (Giữ) thì bỏ qua logic Tap (Chạm)
            if (this.holdTriggered) {
                this.holdTriggered = false;
                this.tapState.count = 0;
                return;
            }

            // Logic Chạm (Tap) thống nhất
            if (this.tapState.timer) clearTimeout(this.tapState.timer);
            this.tapState.count++;
            
            counterEl.style.transform = "scale(0.95)";
            setTimeout(() => counterEl.style.transform = "scale(1)", 80);
            
            // Đợi một chút để xem người dùng có chạm đúp (double tap) không
            this.tapState.timer = setTimeout(() => {
                const taps = this.tapState.count;
                let qualityVal = 4; // Mặc định chạm 1 cái là Thấp (Level 4) hoặc Trung bình (Level 3)
                
                // Logic phân loại của Pro cũ:
                if (taps === 1) qualityVal = 4;      // 1 chạm: Thấp
                else if (taps === 2) qualityVal = 3; // 2 chạm: Trung bình
                else qualityVal = 2;                 
                
                this.triggerMindfulnessSuccess(qualityVal);
                this.tapState.count = 0; 
            }, 400); 
        };
        
        medOverlay.addEventListener('pointerup', handleRelease);
        medOverlay.addEventListener('pointerleave', () => {
            if(pressTimer) clearTimeout(pressTimer);
            counterEl.style.transform = "scale(1)";
            this.holdTriggered = false;
        });
    }
}

triggerAwarenessSuccess() {
    if (!this.meditationState.active || this.meditationState.paused) return;
    
    // Tăng biến đếm Tỉnh giác
    this.meditationState.awarenessCount++;
    
    // Rung phản hồi (Kiểu rung khác: 2 nhịp ngắn nhanh để phân biệt)
    const settings = this.data.medSettings;
    if (settings.vibration && navigator.vibrate) {
        navigator.vibrate([30, 30, 30]); 
    }

    // Hiệu ứng Visual 
    const counterEl = document.getElementById('med-counter');
    const awarenessColor = '#55efc4'; 

    counterEl.style.transition = "transform 0.1s";
    counterEl.style.transform = "scale(1.2)";
    counterEl.style.borderColor = awarenessColor;
    counterEl.style.color = awarenessColor;
    
   
    const currentMindfulness = this.meditationState.count;
   counterEl.innerHTML = '<i class="fas fa-shield-alt"></i>'

    setTimeout(() => {
        counterEl.style.transform = "scale(1)";
        counterEl.style.borderColor = "transparent";
        counterEl.style.color = "white";
        counterEl.innerText = currentMindfulness; // Trả lại số hiển thị Chánh niệm
    }, 400);
}
  openIntroModal() {
        const modal = document.getElementById('intro-modal');
        if (modal) modal.style.display = 'flex';
    }

closeIntroModal() {
    document.getElementById('intro-modal').style.display = 'none';
    localStorage.setItem('intro_seen', 'true'); 
}          

renderQuickTags(containerId, inputId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = ''; 
    
    this.QUICK_TAGS.forEach(tag => {
        const span = document.createElement('span');
        span.className = 'quick-tag';
        span.innerText = tag;
        
        span.onclick = () => {
            const input = document.getElementById(inputId);

            if (input.value.trim().length > 0) {

                if(!input.value.includes(tag)) {
                    input.value += ', ' + tag;
                }
            } else {
                input.value = tag;
            }
        };
        
        container.appendChild(span);
    });
}
            getStartOfWeek(date) {
                const d = new Date(date);
                const day = d.getDay() || 7; 
                const diff = d.getDate() - day + 1; 
                return new Date(d.getFullYear(), d.getMonth(), diff);
            }
changeProWeek(dir) { 
    this.currentWeekStart.setDate(this.currentWeekStart.getDate() + (dir * 7)); 
    this.renderProAnalytics(); 
}

changeProMonth(dir) { 
    this.currentMonth.setMonth(this.currentMonth.getMonth() + dir); 
    this.renderProAnalytics(); 
}

getTouchTimestamp(t, startTime) {
    if (typeof t === 'object' && t !== null) {
        if (t.d !== undefined) return startTime + t.d; 
        if (t.t !== undefined) return t.t;             
    }
    
    if (typeof t === 'number') {
        if (t > 1000000000000) {
            return t; 
        }
        return startTime + t;
    }
    
    return 0;
}

analyzeSingleSession(log) {
    const totalSec = log.minutes * 60;
    if (totalSec === 0) return { distractedSec: 0, qualityPct: 0 };
    const thresholdSec = log.threshold || 6;
    let distractedSec = 0;

    // 1. Tính toán thời gian xao nhãng dựa trên khoảng cách Touch (Chánh niệm)
    if (log.touches && log.touches.length >= 2) {
        const timestamps = log.touches.map(t => this.getTouchTimestamp(t, log.timestamp)).sort((a,b) => a - b);
        
        const startGap = (timestamps[0] - log.timestamp) / 1000;
        if (startGap > thresholdSec) distractedSec += (startGap - thresholdSec/2);

        for (let i = 1; i < timestamps.length; i++) {
            const gap = (timestamps[i] - timestamps[i-1]) / 1000;
            if (gap > thresholdSec) distractedSec += (gap - thresholdSec/2);
        }
        
        const endTime = log.timestamp + (log.minutes * 60 * 1000);
        const endGap = (endTime - timestamps[timestamps.length - 1]) / 1000;
        if (endGap > thresholdSec) distractedSec += (endGap - thresholdSec/2);
    } 
    else {
        // Fallback nếu ít touch
        const count = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);
        let mindfulSec = count * thresholdSec;
        mindfulSec = Math.min(mindfulSec, totalSec);
        distractedSec = totalSec - mindfulSec;
    }

    
    const awarenessCount = log.awarenessCount || 0;
    const holdDurationSec = (this.data.medSettings.holdDuration || 500) / 1000;
    const recoveryTime = awarenessCount * holdDurationSec;
    
    distractedSec -= recoveryTime;

    // Đảm bảo không âm và không vượt quá tổng thời gian
    if (distractedSec < 0) distractedSec = 0;
    distractedSec = Math.min(distractedSec, totalSec);

    const qualityPct = ((totalSec - distractedSec) / totalSec) * 100;
    return { distractedSec, qualityPct: parseFloat(qualityPct.toFixed(1)) };
}

renderAnalytics(saveState = false) {
    const range = parseInt(document.getElementById('ana-time-range').value) || 3;
    const ctxTrend = document.getElementById('analyticsTrendChart').getContext('2d');
    const goalSelect = document.getElementById('ana-goal-select');

    if (saveState) {
        this.analyticsGoalFilter = goalSelect.value;
        localStorage.setItem('anaGoalFilter', this.analyticsGoalFilter);
    }

    const medGoals = this.data.goals.filter(g => g.type === 'meditation');

    goalSelect.innerHTML = '<option value="all">All Sessions</option>';
    medGoals.forEach(g => {
        const opt = document.createElement('option');
        opt.value = g.id;
        opt.innerText = g.name;
        goalSelect.appendChild(opt);
    });

    const goalExists = this.analyticsGoalFilter === 'all' || medGoals.some(g => g.id === this.analyticsGoalFilter);
    if (!goalExists) {
        this.analyticsGoalFilter = 'all';
        localStorage.setItem('anaGoalFilter', 'all');
    }
    goalSelect.value = this.analyticsGoalFilter;

    let targetGoalIds = [];
    if (this.analyticsGoalFilter === 'all') {
        targetGoalIds = medGoals.map(g => g.id);
    } else {
        targetGoalIds = [this.analyticsGoalFilter];
    }

    if (targetGoalIds.length === 0) {
        document.getElementById('ana-comparison-table').innerHTML = '<tr><td colspan="5" style="text-align:center; padding:20px;">There is no meditation goals.</td></tr>';
        return;
    }

    const now = Date.now();
    const cutoff = now - (range * 24 * 60 * 60 * 1000);
    
    const logs = this.data.logs
        .filter(l => targetGoalIds.includes(l.goalId) && l.timestamp >= cutoff)
        .sort((a, b) => a.timestamp - b.timestamp);

    if (logs.length === 0) {
        if(this.charts.analyticsTrend) this.charts.analyticsTrend.destroy();
        if(this.charts.hourlyChart) this.charts.hourlyChart.destroy();
        document.getElementById('ana-avg-quality').innerText = "---";
        document.getElementById('ana-avg-density').innerText = "---";
        document.getElementById('ana-total-mindful').innerText = "---";
        document.getElementById('ana-comparison-table').innerHTML = '<tr><td colspan="5" style="padding:20px; text-align:center;">No meditation data for this period.</td></tr>';
        return;
    }

    let totalTimeSec = 0;
    let totalDistractedSec = 0;
    let totalTouches = 0;
    
    // 1. Map data and include raw timestamp for calculation
    const sessionData = logs.map(log => {
        const result = this.analyzeSingleSession(log);
        
        totalTimeSec += log.minutes * 60;
        totalDistractedSec += result.distractedSec;
        const count = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);
        totalTouches += count;
        const d = new Date(log.timestamp);
        const timeStr = d.getHours().toString().padStart(2, '0') + ':' + 
                        d.getMinutes().toString().padStart(2, '0');
        const dateStr = d.getDate().toString().padStart(2, '0') + '/' + 
                        (d.getMonth() + 1).toString().padStart(2, '0') + '/' + 
                        d.getFullYear();
        
        return {
            timestamp: log.timestamp, // Keep raw timestamp for bucketing
            date: d.toLocaleDateString('vi-VN', {day: '2-digit', month:'2-digit'}),
            fullDateTime: `${timeStr}, ${dateStr}`,
            quality: result.qualityPct,
            density: log.minutes > 0 ? (count / log.minutes).toFixed(1) : 0
        };
    });

    const avgQuality = totalTimeSec > 0 ? ((1 - (totalDistractedSec / totalTimeSec)) * 100).toFixed(1) : 0;
    const avgDensity = totalTimeSec > 0 ? (totalTouches / (totalTimeSec / 60)).toFixed(1) : 0;
    const mindfulSeconds = Math.max(0, totalTimeSec - totalDistractedSec);
    const mindfulHours = (mindfulSeconds / 3600).toFixed(1);
    
    document.getElementById('ana-avg-quality').innerText = `${avgQuality}%`;
    document.getElementById('ana-avg-density').innerText = avgDensity;
    document.getElementById('ana-total-mindful').innerText = `${mindfulHours}h`;

    if (this.charts.analyticsTrend) this.charts.analyticsTrend.destroy();

    // 2. Trend Chart Logic with Time-Window Averaging
    let chartData = sessionData;
    const maxPoints = 30;

    if (sessionData.length > maxPoints) {
        chartData = [];
        // Determine the total time span of the visible data
        const startTime = sessionData[0].timestamp;
        const endTime = sessionData[sessionData.length - 1].timestamp;
        const totalDuration = endTime - startTime;
        
        // Calculate the time step for each point
        const step = totalDuration / maxPoints;

        for (let i = 0; i < maxPoints; i++) {
            const bucketStart = startTime + (i * step);
            const bucketEnd = bucketStart + step;

            // Find all logs that fall into this time bucket
            const bucketLogs = sessionData.filter(d => 
                d.timestamp >= bucketStart && d.timestamp < bucketEnd
            );

            // Edge case: Ensure the very last log is included in the last bucket
            if (i === maxPoints - 1) {
                const lastLog = sessionData[sessionData.length - 1];
                if (!bucketLogs.includes(lastLog)) bucketLogs.push(lastLog);
            }

            if (bucketLogs.length > 0) {
                // Calculate Average Quality for this time frame
                const totalQ = bucketLogs.reduce((sum, item) => sum + item.quality, 0);
                const avgQ = totalQ / bucketLogs.length;

                // Create label based on the bucket start time
                const d = new Date(bucketStart);
                const timeStr = d.getHours().toString().padStart(2, '0') + ':' + 
                                d.getMinutes().toString().padStart(2, '0');
                const dateStr = d.getDate().toString().padStart(2, '0') + '/' + 
                                (d.getMonth() + 1).toString().padStart(2, '0');

                chartData.push({
                    date: dateStr,
                    fullDateTime: `${dateStr} (Avg ${bucketLogs.length} sessions)`, // Indication of averaging
                    quality: parseFloat(avgQ.toFixed(1)),
                    timestamp: bucketStart
                });
            }
        }
    }

    this.charts.analyticsTrend = new Chart(ctxTrend, {
        type: 'line',
        data: {
            labels: chartData.map(d => d.date),
            datasets: [
                {
                    label: 'Mindfulness Quality (%)',
                    data: chartData.map(d => d.quality),
                    borderColor: '#34d399',
                    backgroundColor: 'rgba(52, 211, 153, 0.1)',
                    yAxisID: 'y',
                    fill: true,
                    tension: 0.3
                },
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: true
            },
            elements: {
                point: {
                    hitRadius: 30,     
                    hoverRadius: 4     
                }
            },
            plugins: {
                legend: { display: true, labels: { font: {size: 11}} },             
                tooltip: {
                    titleColor: '#f3f4f6',
                    bodyColor: '#f3f4f6',
                    borderColor: '#374151',
                    borderWidth: 1,
                    padding: 10,
                    displayColors: true,
                    callbacks: {
                        title: function(context) {
                            return chartData[context[0].dataIndex].fullDateTime;
                        },
                        label: function(context) {
                // 1. Get the original label from the dataset (e.g., "Chất lượng trung bình")
                let label = context.dataset.label || '';

                // 2. Override the text ONLY for the tooltip display
                if (label === 'Mindfulness Quality (%)') {
                    label = 'Mindful quality';
                }

                // 3. Construct the final string
                if (label) {
                    label += ': ';
                }
                
                if (context.parsed.y !== null) {
                    label += context.parsed.y;

                    // 4. Add the % sign if it corresponds to the quality dataset
                    if (context.dataset.label === 'Mindfulness Quality (%)') {
                        label += '%';
                    }
                }
                return label;
            },
                        labelColor: function(context) {
                            return {
                                borderColor: context.dataset.borderColor,
                                backgroundColor: context.dataset.borderColor,
                                borderWidth: 0,
                                borderRadius: 2,
                            };
                        }
                    }
                }
            },
            scales: {
                y: {
                    type: 'linear', display: true, position: 'right', min: 0, max: 100,
                    grid: { color: '#374151' }, ticks: { color: '#9ca3af', font: { size: 10 }, callback: function(value) {
                return value + '%';
            } },
                },
				y1: {
        type: 'linear',
        display: true,
        position: 'left', 
        min: 0,
        max: 100,
        grid: { drawOnChartArea: false }, 
        ticks: {
            color: '#9ca3af',
            font: { size: 10 },
            callback: value => value + '%'
        }
    },
                x: {
                    ticks: { color: '#9ca3af', font: { size: 10 }, } 
                },
            }
        }
    });

    this.renderComparisonTable(targetGoalIds);
    this.renderHourlyAnalysis(logs);
}



renderHourlyAnalysis(logs) {
    const canvas = document.getElementById('analyticsHourlyChart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    const hourlyData = Array.from({ length: 24 }, (_, i) => ({
        hour: i,
        totalQuality: 0,
        totalMinutes: 0,
        count: 0
    }));

    logs.forEach(log => {
        const hour = new Date(log.timestamp).getHours();
        const result = this.analyzeSingleSession(log);
        
        hourlyData[hour].totalQuality += result.qualityPct;
        hourlyData[hour].totalMinutes += log.minutes;
        hourlyData[hour].count++;
    });

    const labels = hourlyData.map(d => `${d.hour}h`);
    const qualityPoints = hourlyData.map(d => d.count > 0 ? parseFloat((d.totalQuality / d.count).toFixed(1)) : 0);

    const hourPoints = hourlyData.map(d => parseFloat((d.totalMinutes / 60).toFixed(2)));

    if (this.charts.hourlyChart) this.charts.hourlyChart.destroy();

    this.charts.hourlyChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Quality',
                    data: qualityPoints,
                    borderColor: '#a78bfa',
                    backgroundColor: 'rgba(167, 139, 250, 0.05)',
                    borderWidth: 1.5,
                    yAxisID: 'y',
                    fill: true,
                    tension: 0.3,
                    order: 1
                },
                {
                    label: 'Time practiced ', 
                    data: hourPoints,
                    type: 'bar',
                    backgroundColor: 'rgba(56, 189, 248, 0.2)',
                    borderColor: 'rgba(56, 189, 248, 0.5)',
                    borderWidth: 1,
                    yAxisID: 'y1',
                    order: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: true
            },
            elements: {
                point: {
                    hitRadius: 30,
                    hoverRadius: 2.5,
                    radius: 1.3
                }
            },
            plugins: {
                legend: { display: true, labels: { font: {size: 11}} },	        
                tooltip: {
                    titleColor: '#f3f4f6',
                    bodyColor: '#f3f4f6',
                    borderColor: '#374151',
                    borderWidth: 1,
                    padding: 10,
                    displayColors: true,
                    callbacks: {
                        title: (items) => `${items[0].label} - ${parseInt(items[0].label) + 1}h`,
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) label += ': ';
                            if (context.parsed.y !== null) {
                                if (context.dataset.yAxisID === 'y') {
                                    label += context.parsed.y + '%';
                                } else {
                                    const totalHours = context.parsed.y;

                                    if (totalHours < 1) {
                                        label += Math.round(totalHours * 60) + ' minutes';
                                    } else {
                                        label += totalHours.toFixed(1) + ' hours';
                                    }
                                }
                            }
                            return label;
                        },
                        labelColor: function(context) {
                            return {
                                borderColor: context.dataset.borderColor,
                                backgroundColor: context.dataset.borderColor,
                                borderWidth: 0,
                                borderRadius: 2,
                            };
                        }
                    }
                }
            },
            scales: {
                y: {
                    type: 'linear', display: true, position: 'left', min: 0, max: 100,
                    grid: { color: '#374151' },
                    ticks: { color: '#9ca3af', font: { size: 10 }, callback: function(value) {
                return value + '%';
            } }
                },
                y1: {
                    type: 'linear', display: true, position: 'right',
                    beginAtZero: true,
                    grid: { drawOnChartArea: false },
                    ticks: { 
                        color: '#9ca3af',
                         font: { size: 10 },
                        callback: function(value) { 
                            if (value === 0) return 0;
                            if (value < 1) return Math.round(value * 60) + 'm';
                            return value + 'h'; 
                        }
                    }
                },
                x: {
                    ticks: { color: '#9ca3af', font: { size: 10 }, },
                    grid: { color: 'rgba(55, 65, 81, 0.5)', display: true }
                }
            }
        }
    });
}

getStatsForRange(startTime, endTime, goalIds) {
    const logs = this.data.logs.filter(l => 
        goalIds.includes(l.goalId) && 
        l.timestamp >= startTime && 
        l.timestamp < endTime
    );

    if (logs.length === 0) return { count: 0, minutes: 0, quality: 0, density: 0 };

    let totalMinutes = 0;
    let totalTouches = 0;
    let weightedQualitySum = 0;

    logs.forEach(l => {
        totalMinutes += l.minutes;
        const count = l.count !== undefined ? l.count : (l.touches ? l.touches.length : 0);
        totalTouches += count;

        const analysis = this.analyzeSingleSession(l);
        weightedQualitySum += (l.minutes * analysis.qualityPct);
    });

    return {
        count: logs.length,
        minutes: totalMinutes,
        quality: (weightedQualitySum / totalMinutes).toFixed(1),
        density: (totalTouches / totalMinutes).toFixed(1)
    };
}

renderComparisonTable(medGoalIds) {
    const tbody = document.getElementById('ana-comparison-table');
    tbody.innerHTML = '';

    const now = new Date();
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();

    const startOfYesterday = todayStart - (24 * 60 * 60 * 1000);
    const startOfDaybefore = todayStart - (48 * 60 * 60 * 1000);
    const dayOfWeek = now.getDay(); 
    const diffToMonday = (dayOfWeek === 0 ? 6 : dayOfWeek - 1);
    const startOfThisWeek = new Date(now.getFullYear(), now.getMonth(), now.getDate() - diffToMonday).getTime();
    const startOfLastWeek = startOfThisWeek - (7 * 24 * 60 * 60 * 1000);
    const startOfWeekBefore = startOfThisWeek - (14 * 24 * 60 * 60 * 1000);
    const startOfThisMonth = new Date(now.getFullYear(), now.getMonth(), 1).getTime();
    const startOfLastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1).getTime();
    const startOfMonthBefore = new Date(now.getFullYear(), now.getMonth() - 2, 1).getTime();

   const periods = [
        { label: 'Today', start: todayStart, end: Date.now() },
        { label: 'Yester&#8203;day', start: startOfYesterday, end: todayStart },
		{ label: 'Day Before', start: startOfDaybefore, end: startOfYesterday },
        { label: 'This Week', start: startOfThisWeek, end: Date.now() },
        { label: 'Last Week', start: startOfLastWeek, end: startOfThisWeek },
		{ label: 'Week Before', start: startOfWeekBefore, end: startOfLastWeek },
        { label: 'This Month', start: startOfThisMonth, end: Date.now() },
        { label: 'Last Month', start: startOfLastMonth, end: startOfThisMonth },
		{ label: 'Month Before', start: startOfMonthBefore, end: startOfLastMonth }
    ];

    periods.forEach(p => {

        const stats = this.getStatsForRange(p.start, p.end, medGoalIds);
        const row = document.createElement('tr');
        row.style.borderBottom = '1px solid var(--border)';
        
        let qualityColor = 'var(--text)';
        if(stats.count > 0) {
            if(stats.quality > 70) qualityColor = 'var(--success)';
            else if(stats.quality < 40) qualityColor = 'var(--danger)';
        }

        row.innerHTML = `
            <td style="padding: 12px 10px; font-weight: 500;">${p.label}</td>
            <td style="padding: 12px 10px; text-align: center;">${stats.count}</td>
            <td style="padding: 12px 10px; text-align: center;">${(stats.minutes/60).toFixed(1)}h</td>
            <td style="padding: 12px 10px; text-align: center; color: ${qualityColor}; font-weight:bold;">${stats.count > 0 ? stats.quality + '%' : '-'}</td>
            <td style="padding: 12px 10px; text-align: center;">${stats.count > 0 ? stats.density : '-'}</td>
        `;
        tbody.appendChild(row);
    });
}
        
 renderProAnalytics(resetDates = false) {
    if (!document.getElementById('proWeeklyChart')) return;

    // --- 1. SETUP DATES & RANGES ---
    const rangeSelect = document.getElementById('pro-range-select');
    const rangeMode = rangeSelect ? rangeSelect.value : 'this_week';
    const now = new Date();
    
    const realCurrentDay = now.getDay() || 7; 
    const realThisWeekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - realCurrentDay + 1);
    const realThisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);

    if (resetDates) {
        if (rangeMode === 'last_week') {
            this.currentWeekStart = new Date(realThisWeekStart);
            this.currentWeekStart.setDate(this.currentWeekStart.getDate() - 7);
            this.currentMonth = new Date(this.currentWeekStart.getFullYear(), this.currentWeekStart.getMonth(), 1);
        } 
        else if (rangeMode === 'last_month') {
            this.currentMonth = new Date(realThisMonthStart);
            this.currentMonth.setMonth(this.currentMonth.getMonth() - 1);
            this.currentWeekStart = this.getStartOfWeek(new Date(this.currentMonth.getFullYear(), this.currentMonth.getMonth(), 1));
        }
        else {
            this.currentWeekStart = new Date(realThisWeekStart);
            this.currentMonth = new Date(realThisMonthStart);
        }
    }

    // Calculate Breakdown Range
    let filterStart = 0;
    let filterEnd = Date.now() + 86400000;
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();

    if (rangeMode === 'today') filterStart = todayStart;
    else if (rangeMode === 'yesterday') {
        filterEnd = todayStart;
        filterStart = todayStart - 86400000; 
    }
    else if (rangeMode === 'this_week') filterStart = realThisWeekStart.getTime();
    else if (rangeMode === 'last_week') {
        filterEnd = realThisWeekStart.getTime();
        filterStart = realThisWeekStart.getTime() - (7 * 24 * 60 * 60 * 1000);
    } else if (rangeMode === 'this_month') filterStart = realThisMonthStart.getTime();
    else if (rangeMode === 'last_month') {
        filterEnd = realThisMonthStart.getTime();
        filterStart = new Date(now.getFullYear(), now.getMonth() - 1, 1).getTime();
    }

    // Ranges for Weekly/Monthly Charts
    const weekStartMs = this.currentWeekStart.getTime();
    const weekEndMs = weekStartMs + (7 * 24 * 60 * 60 * 1000);
    const weekEndDisp = new Date(weekEndMs - 1);
    document.getElementById('pro-weekly-title').innerText = `Week (${this.currentWeekStart.toLocaleDateString('en-GB', {month:'numeric', day:'numeric'})} - ${weekEndDisp.toLocaleDateString('vi-VN', {month:'numeric', day:'numeric'})})`;

    const mYear = this.currentMonth.getFullYear();
    const mMonth = this.currentMonth.getMonth();
    const monthlyLabels = Array.from({length: new Date(mYear, mMonth + 1, 0).getDate()}, (_, i) => i + 1);
    document.getElementById('pro-monthly-title').innerText = `Month ${new Date(mYear, mMonth).toLocaleDateString('en-GB', { month: 'numeric', year: 'numeric' })}`;

    // --- 2. PREPARE DATA CONTAINERS (STORING MINUTES) ---
    const qualities = {
		
        1: { label: 'High', color: '#34d399' },
        2: { label: 'Good', color: '#60a5fa' },
        3: { label: 'Medium', color: '#fbbf24' },
        4: { label: 'Low', color: '#f87171' },
        5: { label: 'Alertness', color: '#a78bfa' }, // Added Level 5 for Awareness
        0: { label: 'Distraction', color: '#6b7280' }, 
    };

    // Initialize with 0 for levels 1-5 and 0
    const breakdownData = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 0: 0 };
    const weeklyData = { 
        1: new Array(7).fill(0), 
        2: new Array(7).fill(0), 
        3: new Array(7).fill(0), 
        4: new Array(7).fill(0),
        5: new Array(7).fill(0),
        0: new Array(7).fill(0) 
    };
    const monthlyData = { 
        1: new Array(monthlyLabels.length).fill(0), 
        2: new Array(monthlyLabels.length).fill(0), 
        3: new Array(monthlyLabels.length).fill(0), 
        4: new Array(monthlyLabels.length).fill(0),
        5: new Array(monthlyLabels.length).fill(0),
        0: new Array(monthlyLabels.length).fill(0) 
    };

    // --- 3. DATA AGGREGATION LOGIC ---
    this.data.logs.forEach(log => {
        // Skip logs without touches (or handle standard logs differently if needed, but Pro view focuses on touches)
        if (!log.touches || log.touches.length === 0) return;

        // 1. Calculate Total Mindful Time vs Distracted Time (in Seconds)
        const analysis = this.analyzeSingleSession(log);
        const totalSec = log.minutes * 60;
        const distractedSec = analysis.distractedSec;

        // Calculate Recovery Time (Tỉnh giác)
        const holdDurationSec = (this.data.medSettings.holdDuration || 500) / 1000;
        const recoverySec = (log.awarenessCount || 0) * holdDurationSec;

        // Pure Mindful Time = Total - Distracted - Recovery
        // (Note: analyzeSingleSession already reduces distractedSec by recoverySec, so Total - Distracted includes Recovery. We subtract it here to separate them.)
        const mindfulSec = Math.max(0, totalSec - distractedSec - recoverySec);

        // 2. Count Pro touches to calculate ratios for Mindful Time
        const logCounts = { 1: 0, 2: 0, 3: 0, 4: 0 };
        let totalLogProTouches = 0;

        log.touches.forEach(t => {
            if (t.v) {
                logCounts[t.v]++;
                totalLogProTouches++;
            }
        });

        // 3. Prepare Time Buckets
        const logTime = log.timestamp;
        const logDateObj = new Date(logTime);
        
        // Determine array indices
        let weekDayIdx = -1;
        if (logTime >= weekStartMs && logTime < weekEndMs) {
            let d = logDateObj.getDay();
            weekDayIdx = (d === 0 ? 6 : d - 1);
        }
        
        let monthDayIdx = -1;
        if (logDateObj.getFullYear() === mYear && logDateObj.getMonth() === mMonth) {
            monthDayIdx = logDateObj.getDate() - 1;
        }

        // Helper to add minutes
        const addMinutes = (level, minutes) => {
            if (logTime >= filterStart && logTime < filterEnd) {
                breakdownData[level] += minutes;
            }
            if (weekDayIdx !== -1) weeklyData[level][weekDayIdx] += minutes;
            if (monthDayIdx !== -1) monthlyData[level][monthDayIdx] += minutes;
        };

        // 4. Distribute "Distracted" Time (Level 0)
        if (distractedSec > 0) {
            addMinutes(0, distractedSec / 60);
        }

        // 5. Distribute "Awareness" Time (Level 5 - Tỉnh giác)
        if (recoverySec > 0) {
            addMinutes(5, recoverySec / 60);
        }

        // 6. Distribute "Mindful" Time (Levels 1-4)
        if (totalLogProTouches > 0) {
            [1, 2, 3, 4].forEach(level => {
                if (logCounts[level] > 0) {
                    const levelSeconds = (logCounts[level] / totalLogProTouches) * mindfulSec;
                    addMinutes(level, levelSeconds / 60);
                }
            });
        }
    });

    const formatTime = (mins) => {
        if (mins >= 60) return (mins / 60).toFixed(1) + 'h';
        return mins.toFixed(0) + 'm';
    };

    const formatTimeDetailed = (mins) => {
        if (mins >= 60) return (mins / 60).toFixed(1) + 'h';
        return mins.toFixed(1) + 'm';
    };
    const weekDays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    // --- 4. RENDER BREAKDOWN CHART ---
    const ctxBreakdown = document.getElementById('proBreakdownChart').getContext('2d');
    if (this.charts.proBreakdown) this.charts.proBreakdown.destroy();

    // Total Minutes (Mindful + Awareness + Distracted)
    const totalBreakdown = Object.values(breakdownData).reduce((a, b) => a + b, 0);

    // Calculate Average Score (Only based on Mindful time, i.e., levels 1-4)
    let averageScore = 0;
    const totalMindfulMinutes = breakdownData[1] + breakdownData[2] + breakdownData[3] + breakdownData[4];
    
    if (totalMindfulMinutes > 0) {
        const weightedSum = (breakdownData[1] * 4) + 
                            (breakdownData[2] * 3) + 
                            (breakdownData[3] * 2) + 
                            (breakdownData[4] * 1);
        averageScore = (weightedSum / totalMindfulMinutes).toFixed(2);
    }

    this.charts.proBreakdown = new Chart(ctxBreakdown, {
        type: 'bar',
        data: {
            labels: ['Focus level'],
            datasets: [
                { label: qualities[1].label, data: [breakdownData[1]], backgroundColor: qualities[1].color, borderRadius: { topLeft: 8, bottomLeft: 8 } },
                { label: qualities[2].label, data: [breakdownData[2]], backgroundColor: qualities[2].color },
                { label: qualities[3].label, data: [breakdownData[3]], backgroundColor: qualities[3].color },
                { label: qualities[4].label, data: [breakdownData[4]], backgroundColor: qualities[4].color },
                { label: qualities[5].label, data: [breakdownData[5]], backgroundColor: qualities[5].color }, // Awareness
                { label: qualities[0].label, data: [breakdownData[0]], backgroundColor: qualities[0].color, borderRadius: { topRight: 8, bottomRight: 8 } }
            ]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true, display: true,
                    grid: { display: true, color: 'rgba(55, 65, 81, 0.5)' },
                    ticks: { 
                        display: true, color: '#9ca3af', font: { size: 10 },
                        callback: function(value) { return formatTime(value); }
                    }
                },
                y: { stacked: true, display: false }
            },
            plugins: {
                legend: {
                    display: true, position: 'bottom',
                    labels: {
                        color: '#9ca3af', usePointStyle: true, padding: 20, font: { size: 12 },
                        generateLabels: function(chart) {
                            const data = chart.data;
                            return data.datasets.map((dataset, i) => {
                                const val = dataset.data[0];
                                const pct = totalBreakdown > 0 ? ((val / totalBreakdown) * 100).toFixed(1) : 0;
                                const isHidden = !chart.isDatasetVisible(i);
                                return {
                                    text: `${dataset.label} (${pct}%)`,
                                    fillStyle: dataset.backgroundColor, strokeStyle: 'transparent',
                                    fontColor: isHidden ? '#6b7280' : '#9ca3af',
                                    pointStyle: 'circle', datasetIndex: i, hidden: isHidden
                                };
                            });
                        }
                    }
                },
                tooltip: {
                    backgroundColor: '#1f2937',
                    callbacks: {
                        label: function(context) {
                            const val = context.raw; 
                            const pct = totalBreakdown > 0 ? ((val / totalBreakdown) * 100).toFixed(1) : 0;
                            return ` ${context.dataset.label}: ${formatTimeDetailed(val)} (${pct}%)`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: totalBreakdown === 0 ? 'No data available' : `Average focus level: ${averageScore} / 4.0`,
                    color: totalBreakdown === 0 ? '#6b7280' : '#f3f4f6',
                    font: { size: 14, style: 'italic', weight: totalBreakdown === 0 ? 'normal' : '600' },
                    padding: { top: 10, bottom: 10 }
                },
            }
        }
    });

    // --- 5. RENDER WEEKLY & MONTHLY CHARTS ---
    const commonOptions = {
        maintainAspectRatio: false,
        scales: {
            x: { stacked: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af', font: { size: 11 } } },
            y: { 
                stacked: true, 
                grid: { color: '#374151' }, 
                title: { display: false }, 
                ticks: { 
                    color: '#9ca3af', font: { size: 10 },
                    callback: function(value) { return formatTime(value); }
                } 
            }
        },
        plugins: {
            legend: { labels: { color: '#9ca3af', font: {size: 11} } },
            tooltip: {
                callbacks: {
                    label: (context) => {
                        const label = context.dataset.label || '';
                        const value = context.raw;
                        let total = 0;
                        context.chart.data.datasets.forEach((dataset, i) => {
                            if (context.chart.isDatasetVisible(i)) {
                                total += dataset.data[context.dataIndex];
                            }
                        });
                        const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                        return `${label}: ${formatTimeDetailed(value)} (${percentage}%)`;
                    }
                }
            }
        }
    };

    // Weekly Chart
    const weeklyOptions = {
        ...commonOptions,
        plugins: {
            ...commonOptions.plugins,
            tooltip: {
                ...commonOptions.plugins.tooltip,
                callbacks: {
                    ...commonOptions.plugins.tooltip.callbacks,
                    title: (context) => {
                        const dayIndex = context[0].dataIndex;
                        const date = new Date(this.currentWeekStart);
                        date.setDate(date.getDate() + dayIndex);
                        const day = String(date.getDate()).padStart(2, '0');
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        return `${context[0].label} (${day}/${month})`;
                    }
                }
            }
        }
    };

    const ctxWeekly = document.getElementById('proWeeklyChart').getContext('2d');
    if (this.charts.proWeekly) this.charts.proWeekly.destroy();
    this.charts.proWeekly = new Chart(ctxWeekly, {
        type: 'bar',
        data: {
            labels: weekDays,
            datasets: [
                { label: qualities[1].label, data: weeklyData[1], backgroundColor: qualities[1].color },
                { label: qualities[2].label, data: weeklyData[2], backgroundColor: qualities[2].color },
                { label: qualities[3].label, data: weeklyData[3], backgroundColor: qualities[3].color },
                { label: qualities[4].label, data: weeklyData[4], backgroundColor: qualities[4].color },
                { label: qualities[5].label, data: weeklyData[5], backgroundColor: qualities[5].color }, // Awareness
                { label: qualities[0].label, data: weeklyData[0], backgroundColor: qualities[0].color }
            ]
        },
        options: weeklyOptions 
    });

    // Monthly Chart
    const monthlyOptions = {
        ...commonOptions,
        plugins: {
            ...commonOptions.plugins,
            tooltip: {
                ...commonOptions.plugins.tooltip,
                callbacks: {
                    ...commonOptions.plugins.tooltip.callbacks,
                    title: (context) => {
                         const d = context[0].label;
                         return `${String(d).padStart(2, '0')}/${String(mMonth + 1).padStart(2, '0')}`;
                    }
                }
            }
        }
    };

    const ctxMonthly = document.getElementById('proMonthlyChart').getContext('2d');
    if (this.charts.proMonthly) this.charts.proMonthly.destroy();
    this.charts.proMonthly = new Chart(ctxMonthly, {
        type: 'bar',
        data: {
            labels: monthlyLabels,
            datasets: [
                { label: qualities[1].label, data: monthlyData[1], backgroundColor: qualities[1].color },
                { label: qualities[2].label, data: monthlyData[2], backgroundColor: qualities[2].color },
                { label: qualities[3].label, data: monthlyData[3], backgroundColor: qualities[3].color },
                { label: qualities[4].label, data: monthlyData[4], backgroundColor: qualities[4].color },
                { label: qualities[5].label, data: monthlyData[5], backgroundColor: qualities[5].color }, // Awareness
                { label: qualities[0].label, data: monthlyData[0], backgroundColor: qualities[0].color }
            ]
        },
        options: monthlyOptions
    });

    this.renderProTrendChart();
}
renderProTrendChart() {
    const ctxTrend = document.getElementById('proTrendChart');
    if (!ctxTrend) return;
    const ctx = ctxTrend.getContext('2d');

    // 1. Determine Time Range
    const selectEl = document.getElementById('pro-trend-select');
    const rangeVal = selectEl ? selectEl.value : '30';
    
    let filterStart = 0;
    const now = Date.now();

    if (rangeVal === 'all') {
        filterStart = 0;
    } else {
        const days = parseInt(rangeVal);
        filterStart = now - (days * 24 * 60 * 60 * 1000);
    }

    // 2. Filter Logs (Only logs with Pro data)
    let trendLogs = this.data.logs
        .filter(l => l.timestamp >= filterStart)
        .filter(l => l.touches && l.touches.some(t => t.v)) 
        .sort((a, b) => a.timestamp - b.timestamp);

    if (trendLogs.length === 0) {
        if (this.charts.proTrend) this.charts.proTrend.destroy();
        return;
    }

    // 3. Pre-calculate score for every valid session
    const sessionData = trendLogs.map(log => {
        const proTouches = log.touches.filter(t => t.v);
        const totalScore = proTouches.reduce((sum, t) => sum + (5 - t.v), 0);
        const avg = proTouches.length > 0 ? (totalScore / proTouches.length) : 0;
        
        const d = new Date(log.timestamp);
        // Formats for tooltip and labels
        const timeStr = d.getHours().toString().padStart(2, '0') + ':' + 
                        d.getMinutes().toString().padStart(2, '0');
        const dateStr = d.getDate().toString().padStart(2, '0') + '/' + 
                        (d.getMonth() + 1).toString().padStart(2, '0');

        return {
            timestamp: log.timestamp,
            date: dateStr,
            fullDateTime: `${timeStr}, ${dateStr}`, 
            score: avg
        };
    });

    // 4. Data Aggregation (Time-Window Averaging)
    // Similar to analyticsTrend: Bin data into buckets to show a true trend
    let chartData = [];
    const maxPoints = 30; // Match analytics chart density

    if (sessionData.length <= maxPoints) {
        // If we have fewer logs than maxPoints, show them all directly
        chartData = sessionData.map(d => ({
            label: d.date,
            score: parseFloat(d.score.toFixed(2)),
            tooltipTitle: d.fullDateTime
        }));
    } else {
        // Otherwise, bucket them by time
        const startTime = sessionData[0].timestamp;
        const endTime = sessionData[sessionData.length - 1].timestamp;
        const totalDuration = endTime - startTime;
        const step = totalDuration / maxPoints;

        for (let i = 0; i < maxPoints; i++) {
            const bucketStart = startTime + (i * step);
            const bucketEnd = bucketStart + step;

            // Find all sessions in this time window
            const bucketLogs = sessionData.filter(d => 
                d.timestamp >= bucketStart && d.timestamp < bucketEnd
            );

            // Ensure the very last log is included
            if (i === maxPoints - 1) {
                const lastLog = sessionData[sessionData.length - 1];
                if (!bucketLogs.includes(lastLog)) bucketLogs.push(lastLog);
            }

            if (bucketLogs.length > 0) {
                // Calculate Average Score for this bucket
                const totalQ = bucketLogs.reduce((sum, item) => sum + item.score, 0);
                const avgQ = totalQ / bucketLogs.length;

                const d = new Date(bucketStart);
                const dateStr = d.getDate().toString().padStart(2, '0') + '/' + 
                                (d.getMonth() + 1).toString().padStart(2, '0');

                chartData.push({
                    label: dateStr,
                    score: parseFloat(avgQ.toFixed(2)),
                    // Tooltip indicates this is an average
                    tooltipTitle: `${dateStr} (Avg ${bucketLogs.length} Sessions)` 
                });
            }
        }
    }

    // 5. Render Chart
    if (this.charts.proTrend) this.charts.proTrend.destroy();

    this.charts.proTrend = new Chart(ctx, {
        type: 'line',
        data: {
            labels: chartData.map(d => d.label),
            datasets: [
                {
                    label: 'Average focus level',
                    data: chartData.map(d => d.score),
                    borderColor: '#818cf8', // Emerald-500 equivalent style
                    backgroundColor: 'rgba(129, 140, 248, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: true
            },
            elements: {
                point: {
                    hitRadius: 30,     
                    hoverRadius: 4     
                }
            },
            scales: {
                y: {
                    type: 'linear',
                    display: true,
                    min: 0,
                    max: 4.2, 
                    grid: { color: '#374151' },
                    ticks: {
                        color: '#9ca3af',
                        font: { size: 10 },
                        stepSize: 1,
                        padding: 0.1,
                        callback: function(value) {
                            if(value === 1) return 'Low (1)';
                            if(value === 2) return 'Med (2)';
                            if(value === 3) return 'Good (3)';
                            if(value === 4) return 'High (4)';
							if(value === 0) return '☁️ (0)';
                            return '';
                        }
                    }
                },
                x: {
                    ticks: { color: '#9ca3af', font: { size: 10 } },
                    grid: { color: 'rgba(55, 65, 81, 0.5)' }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    titleColor: '#f3f4f6',
                    bodyColor: '#f3f4f6',
                    borderColor: '#374151',
                    borderWidth: 1,
                    padding: 10,
                    displayColors: false,
                    callbacks: {
                        title: (context) => chartData[context[0].dataIndex].tooltipTitle,
                        label: function(context) {
                            return `Focus level: ${context.parsed.y} / 4.0`;
                        }
                    }
                }
            }
        }
    });
}
triggerMindfulnessSuccess(quality = 4) {
    const settings = this.data.medSettings;
    const now = Date.now();
    
    // Logic Combo & Auto Level (Tự động tăng mức độ khó/chất lượng theo thời gian)
    const thresholdMs = this.meditationState.threshold * 1000;
    const timeDiff = now - this.meditationState.lastTouchTime;

    let nextAutoLevel = this.meditationState.currentAutoLevel;
    let nextComboCounter = this.meditationState.comboCounter;

    // Nếu khoảng cách giữa 2 lần chạm quá lâu (thất niệm) -> Reset về mức thấp
    if (timeDiff > thresholdMs) {
        nextAutoLevel = 4;
        nextComboCounter = 0;
    } else {
        // Nếu duy trì tốt, tăng combo
        if (nextAutoLevel > 1) {
            nextComboCounter++;
            const hitsRequired = 15;
            if (nextComboCounter >= hitsRequired) {
                nextAutoLevel--; // Giảm số Level (1 là cao nhất)
                nextComboCounter = 0;
            }
        }
    }

    // --- LOGIC PRO THỐNG NHẤT ---
    let finalQuality = nextAutoLevel; 
    let potentialProQuality = quality;
    
    finalQuality = Math.min(potentialProQuality, nextAutoLevel);

    // --- LOGIC XÁC NHẬN (CONFIRM MODE) ---
    const isLowQuality = (finalQuality === 4);
    let needConfirm = false;

    if (settings.confirmMode && isLowQuality) {
        if (this.meditationState.pendingConfirmation) {
            needConfirm = true; 
        } else {
            const chance = settings.confirmProbability || 100;
            const roll = Math.random() * 100;
            if (roll <= chance) {
                needConfirm = true;
            }
        }
    }

    if (needConfirm) {
        const counterEl = document.getElementById('med-counter');

        if (!this.meditationState.pendingConfirmation) {
            this.meditationState.pendingConfirmation = true;
            this.meditationState.pendingTouchData = { 
                quality: finalQuality, 
                timestamp: now 
            };
            
            counterEl.style.transition = "all 0.2s";
            counterEl.style.borderColor = "var(--warning)";
            counterEl.style.color = "var(--warning)";
            counterEl.style.transform = "scale(0.85)";
          
            this.meditationState.confirmationTimeout = setTimeout(() => {
                this.meditationState.pendingConfirmation = false;
                this.meditationState.pendingTouchData = null;
                
                counterEl.style.borderColor = "transparent";
                counterEl.style.color = "white";
                counterEl.style.transform = "scale(1)";
            }, 3000); 

            return; // Dừng lại chờ xác nhận
        } else {
            clearTimeout(this.meditationState.confirmationTimeout);
            this.meditationState.pendingConfirmation = false;
        }
    }

    // Cập nhật trạng thái
    this.meditationState.currentAutoLevel = nextAutoLevel;
    this.meditationState.comboCounter = nextComboCounter;
    this.meditationState.lastTouchTime = now;

    // Đếm combo Good cho Pro
    if (quality === 2) {
        this.meditationState.consecutiveGoodCount = (this.meditationState.consecutiveGoodCount || 0) + 1;
    } else {
        this.meditationState.consecutiveGoodCount = 0;
    }

    this.handleMeditationTouch(finalQuality);

    // Rung phản hồi
    if (settings.vibration && navigator.vibrate) {
        switch(finalQuality) {
            case 1: navigator.vibrate([80, 50, 80]); break; 
            case 2: navigator.vibrate([60, 40, 60]); break; 
            case 3: navigator.vibrate([40, 30, 40]); break; 
            case 4: navigator.vibrate(50); break;           
            default: navigator.vibrate(50);
        }
    }

    // Hiệu ứng Visual
    const counterEl = document.getElementById('med-counter');
    const colors = { 1: 'var(--q-1)', 2: 'var(--q-2)', 3: 'var(--q-3)', 4: 'var(--q-4)' }; 
    const pulseColor = colors[finalQuality] || 'var(--q-4)';

    counterEl.style.transition = "transform 0.1s";
    counterEl.style.transform = "scale(1.3)";
    counterEl.style.borderColor = pulseColor;
    counterEl.style.color = pulseColor; 

    setTimeout(() => {
        counterEl.style.transform = "scale(1)";
        counterEl.style.borderColor = "transparent";
        counterEl.style.color = "white";
    }, 200);
}

            save() {
                // We perform a "fire and forget" save to DB
                dbHelper.saveAll(this.data).catch(err => {
                    console.error("Save failed:", err);
                    this.showToast("Save failed!");
                });
                
                this.updateStats();
            }
get totalMindfulnessCounts() {
    return this.data.logs.reduce((sum, log) => {

        return sum + (log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0));
    }, 0);
}			

            playBell() {
                const audio = document.getElementById('bell');
                if (audio) {
                    audio.currentTime = 0;
                    audio.play().catch(e => console.log("Audio play failed (autoplay blocked):", e));
                }
            }

            saveGoal(e) {
                e.preventDefault();
                const id = document.getElementById('g-id').value;
                const type = document.getElementById('g-type').value || 'standard';
                const name = document.getElementById('g-name').value;
                const category = document.getElementById('g-cat').value;
                const color = document.getElementById('g-color').value;
                const lifetimeTarget = parseInt(document.getElementById('g-lifetime-target').value);
                const dailyTarget = parseInt(document.getElementById('g-daily-target').value);

                if (id) {
                    const goal = this.data.goals.find(g => g.id === id);
                    if (goal) {
                        goal.name = name; goal.category = category; goal.color = color;
                        goal.lifetimeTargetMinutes = lifetimeTarget; goal.dailyTargetMinutes = dailyTarget;
                        this.showToast('Goal Updated!');
                    }
                } else {
                    const newGoal = {
                        id: Date.now().toString(), type, name, category, color,
                        lifetimeTargetMinutes: lifetimeTarget, dailyTargetMinutes: dailyTarget || 0,
                        totalMinutes: 0, totalMindfulness: 0, sessionTargetSeconds: 0,
                        remainingSeconds: 0, currentSessionStartTime: null, isActive: false
                    };
                    this.data.goals.push(newGoal);
                    this.showToast('Goal Created!');
                }
                this.save();
                this.renderGoals();
                this.closeModal();
            }

            

toggleTimer(id) {
    const goal = this.data.goals.find(g => g.id === id);
    if (!goal) return;

    // Tắt các timer khác đang chạy (để chỉ chạy 1 cái một lúc)
    this.data.goals.forEach(g => {
        if (g.isActive && g.id !== id && g.type === 'standard') this.toggleTimer(g.id);
    });

    // Nếu là Thiền (Meditation) -> Chuyển sang hàm khác (không áp dụng fix này ở đây)
    if (goal.type === 'meditation') {
        this.startMeditationSetup(goal);
        return;
    }

    if (goal.isActive) {
        // --- KHI BẤM DỪNG (STOP) ---
        clearInterval(this.timers[id]);
        goal.isActive = false;

        // [QUAN TRỌNG] Tắt âm thanh nền để tiết kiệm pin khi không đếm giờ
        if (this.noSleepAudio) {
            this.noSleepAudio.pause();
            this.noSleepAudio.currentTime = 0;
        }
        
        // Tính toán thời gian đã trôi qua
        const spentSeconds = goal.sessionTargetSeconds - goal.remainingSeconds;
        const minutesSpent = Math.floor(spentSeconds / 60);
        const startTime = goal.currentSessionStartTime || Date.now();
        
        // Reset
        goal.sessionTargetSeconds = 0; 
        goal.remainingSeconds = 0; 
        goal.currentSessionStartTime = null;
        goal.targetEndTime = null;

       if (minutesSpent > 0) this.openSessionModal(id, minutesSpent, null, startTime);
        else this.showToast('Session too short.');

    } else {
        const defaultTime = goal.lastDuration || '20';
        const minStr = prompt('Duration (mins):', defaultTime);
        
        if (!minStr) return;
        const min = parseInt(minStr);
        if (isNaN(min) || min <= 0) return;

        goal.lastDuration = min; 
        this.save(); 

        // [QUAN TRỌNG] Bật âm thanh nền để giữ trình duyệt thức
        if (this.noSleepAudio) {
            this.noSleepAudio.play().catch(e => console.log("Audio block: need interaction"));
        }

        goal.sessionTargetSeconds = min * 60;
        goal.remainingSeconds = goal.sessionTargetSeconds;
        goal.isActive = true;
        goal.currentSessionStartTime = Date.now(); 
        
        // [FIX] Tính thời điểm kết thúc (Target Time)
        goal.targetEndTime = Date.now() + (goal.remainingSeconds * 1000);

        this.timers[id] = setInterval(() => {
            // [FIX] Tính giây còn lại dựa trên thời gian thực
            const now = Date.now();
            const secondsLeft = Math.ceil((goal.targetEndTime - now) / 1000);
            
            goal.remainingSeconds = secondsLeft > 0 ? secondsLeft : 0;

            if (secondsLeft <= 0) {
                // --- HOÀN THÀNH ---
                clearInterval(this.timers[id]);
                
                // Chuông sẽ reo đúng giờ nhờ Audio giữ trình duyệt thức
                this.playBell(); 
                
                // Tắt âm thanh nền
                if (this.noSleepAudio) {
                    this.noSleepAudio.pause();
                    this.noSleepAudio.currentTime = 0;
                }

                goal.isActive = false;
                goal.targetEndTime = null;
                
                const minutesSpent = Math.floor(goal.sessionTargetSeconds / 60);
                const startTime = goal.currentSessionStartTime;
                goal.sessionTargetSeconds = 0; 
                goal.remainingSeconds = 0; 
                goal.currentSessionStartTime = null;
                
                this.openSessionModal(id, minutesSpent, null, startTime);
                this.showToast('Hoàn thành!');
                this.renderGoals(); 
            }
        }, 1000);
    }
    this.renderGoals();
}

startMeditationSetup(goal) {
    const defaultTime = goal.lastDuration || '20';
    const minStr = prompt('Meditation duration (mins):', defaultTime);
    
    if (!minStr) return;
    const min = parseInt(minStr);
    if (isNaN(min) || min <= 0) return;

    const defaultThreshold = goal.lastThreshold || '9';
    const threshStr = prompt('Distraction Threshold (secs):\n(maximum allowed time for 1 mindfulness log)', defaultThreshold);
    let threshold = 9; 
    
    if (threshStr && !isNaN(parseInt(threshStr)) && parseInt(threshStr) > 0) {
        threshold = parseInt(threshStr);
    }

    goal.lastDuration = min;
    goal.lastThreshold = threshold;
    this.save(); 
    
    if (typeof Website2APK !== 'undefined') {
        Website2APK.keepScreenOn(true); 
    }

    this.meditationState = {
        active: true, paused: false, goalId: goal.id, 
        count: 0,           // Đếm Chánh niệm (Tap)
        awarenessCount: 0,  // Đếm Tỉnh giác (Hold) - MỚI
        startTime: Date.now(), totalDurationSeconds: min * 60,
        remainingSeconds: min * 60, touches: [],
        threshold: threshold, 
        quoteInterval: null,
        
        currentAutoLevel: 4,      
        comboCounter: 0,          
        lastTouchTime: Date.now(), 
        
        consecutiveGoodCount: 0, 

        pendingConfirmation: false,
        pendingTouchData: null,
        confirmationTimeout: null
    };

    document.getElementById('meditation-overlay').style.display = 'flex';
    document.getElementById('med-counter').innerText = '0';
    this.updateMedTimerDisplay();

    this.updateMeditationQuote(true); 
    this.meditationState.quoteInterval = setInterval(() => {
        if(!this.meditationState.paused) {
            this.updateMeditationQuote(false);
        }
    }, 8000); 

    this.meditationState.timerRef = setInterval(() => {
        if (!this.meditationState.paused) {
            if (this.meditationState.remainingSeconds > 0) {
                this.meditationState.remainingSeconds--;
                this.updateMedTimerDisplay();
            } else {
                this.concludeMeditationSession('auto');
            }
        }
    }, 1000);
}

            updateMedTimerDisplay() {
                const s = this.meditationState.remainingSeconds;
                const m = Math.floor(s / 60);
                const sec = s % 60;
                document.getElementById('med-timer').innerText = `${m}:${sec.toString().padStart(2, '0')}`;
            }

            handleMeditationTouch(value = 1, customTimestamp = null) {
    if (!this.meditationState.active || this.meditationState.paused) return;
    this.meditationState.count++;

    const touchTime = customTimestamp || Date.now();
    const touchData = { t: touchTime };
    touchData.v = value;
  

    this.meditationState.touches.push(touchData);
    
    const el = document.getElementById('med-counter');
    el.innerText = this.meditationState.count;
}

           
        updateMeditationQuote(isFirstTime = false) {
    const container = document.getElementById('med-quote-container');
    const txt = document.getElementById('med-quote-text');

    if (isFirstTime) {

        const randomItem = DHAMMAPADA[Math.floor(Math.random() * DHAMMAPADA.length)];
        txt.innerHTML = randomItem.t;
        container.style.opacity = '1';
    } else {

        container.style.opacity = '0';
        setTimeout(() => {
            const randomItem = DHAMMAPADA[Math.floor(Math.random() * DHAMMAPADA.length)];
            txt.innerHTML = randomItem.t;
            container.style.opacity = '1';
        }, 1000);
    }
}   

concludeMeditationSession(type = 'manual') {
	if (type === 'manual') {
        if (!confirm("Do you want to stop meditating?")) {
            return;
        }
    }
	
    clearInterval(this.meditationState.timerRef);

    if (this.meditationState.quoteInterval) {
        clearInterval(this.meditationState.quoteInterval);
    }

    if (typeof Website2APK !== 'undefined') {
        Website2APK.keepScreenOn(false); 
    }

    if (type === 'auto') {
        this.playBell();
    }
    
    document.getElementById('meditation-overlay').style.display = 'none';
    
    const durationSeconds = this.meditationState.totalDurationSeconds - this.meditationState.remainingSeconds;
    const minutes = Math.ceil(durationSeconds / 60);
    
    if (minutes <= 0) {
        this.showToast("Session too short");
        this.meditationState.active = false;
        return;
    }
    
    document.getElementById('med-finish-count').innerText = this.meditationState.count;
    document.getElementById('med-finish-time').innerText = minutes + 'm';
    document.getElementById('med-finish-notes').value = '';
	this.renderQuickTags('finish-tags', 'med-finish-notes');
	const discardBtn = document.getElementById('btn-med-discard');
    const actionContainer = document.getElementById('med-finish-actions');

    if (discardBtn && actionContainer) {
        if (type === 'auto') {
            // Khi hết giờ: Ẩn nút Hủy và căn giữa nút Lưu
            discardBtn.style.display = 'none';
            actionContainer.style.justifyContent = 'center';
        } else {
            // Khi bấm dừng thủ công: Hiện đầy đủ và căn phải như cũ
            discardBtn.style.display = 'block';
            actionContainer.style.justifyContent = 'flex-end';
        }
    }
    document.getElementById('meditation-finish-modal').style.display = 'flex';
}
            
            discardMeditation() {
                document.getElementById('meditation-finish-modal').style.display = 'none';
                this.meditationState.active = false;
                this.showToast("Session Discarded");
            }

            saveMeditationLog() {
    const durationSeconds = this.meditationState.totalDurationSeconds - this.meditationState.remainingSeconds;
    const minutes = Math.ceil(durationSeconds / 60);
    const notes = document.getElementById('med-finish-notes').value;

    const goal = this.data.goals.find(g => g.id === this.meditationState.goalId);
    
    // Định dạng ghi chú tự động
    const autoNote = `Mindfulness: ${this.meditationState.count} | Alertness: ${this.meditationState.awarenessCount}.`;

    const log = {
        goalId: goal.id,
        date: this.toIsoDate(new Date(this.meditationState.startTime)),
        timestamp: this.meditationState.startTime,
        minutes: minutes,
        notes: `${autoNote} ${notes}`,
        
        count: this.meditationState.count,                  // Chỉ lưu số Chánh niệm (Tap)
        awarenessCount: this.meditationState.awarenessCount,// Lưu số Tỉnh giác (Hold)
        
        touches: this.meditationState.touches.map(t => {
            const delta = Math.max(0, t.t - this.meditationState.startTime);
            return t.v ? { d: delta, v: t.v } : delta;
        }),
        threshold: this.meditationState.threshold 
    };

    this.data.logs.push(log);
    goal.totalMinutes += minutes;
    if (!goal.totalMindfulness) goal.totalMindfulness = 0;
    goal.totalMindfulness += this.meditationState.count;

    this.meditationState.active = false;
    this.save();
    this.recalculateStreak();
    this.renderGoals();
    this.renderReports();
    const newBadges = this.checkAchievements(true);
    
    document.getElementById('meditation-finish-modal').style.display = 'none';
    this.showToast(`Session saved! +${this.meditationState.count} mindfulness, +${this.meditationState.awarenessCount} awareness.`);
	if (newBadges.length > 0) {
        setTimeout(() => {
            newBadges.forEach((title, index) => {
                // Nếu mở khóa nhiều cái cùng lúc, hiện lần lượt cách nhau 3.5s
                setTimeout(() => {
                    this.showToast(`💎 Unlocked Pāramī: ${title}`, true);
                }, index * 3500); 
            });
        }, 1000); 
    }
}

            updateTimerUI() {
                const todayStr = this.toIsoDate(new Date());
                this.data.goals.forEach(goal => {
                    if (goal.type === 'meditation') return; 
                    let activeSessionMins = 0;
                    let sessionPctVal = 0;
                    if (goal.isActive) {
                        const display = document.getElementById(`timer-${goal.id}`);
                        if (display) display.innerText = this.formatTime(goal.remainingSeconds);
                        const activeSessionSeconds = goal.sessionTargetSeconds - goal.remainingSeconds;
                        activeSessionMins = Math.floor(activeSessionSeconds / 60);
                        sessionPctVal = goal.sessionTargetSeconds > 0 ? (activeSessionSeconds / goal.sessionTargetSeconds) * 100 : 0;
                    }
                    const sessionBar = document.getElementById(`bar-session-${goal.id}`);
                    const sessionText = document.getElementById(`prog-text-session-${goal.id}`);
                    if (sessionBar) sessionBar.style.width = `${sessionPctVal}%`;
                    if (sessionText) sessionText.innerText = goal.isActive ? `${activeSessionMins} / ${Math.floor(goal.sessionTargetSeconds / 60)} mins` : "Ready";
                });
                this.updateStats(); 
            }


openMedSettings() {
    const s = this.data.medSettings;
    
    // Gán giá trị vào input
    document.getElementById('inp-hold-time').value = s.holdDuration || 500;
    document.getElementById('disp-hold-time').innerText = ((s.holdDuration || 500) / 1000) + 's';
    
    document.getElementById('inp-vibrate').checked = s.vibration;
    document.getElementById('inp-confirm-mode').checked = s.confirmMode || false;
    
    const prob = (typeof s.confirmProbability !== 'undefined') ? s.confirmProbability : 100;
    document.getElementById('inp-confirm-prob').value = prob;
    document.getElementById('disp-confirm-prob').innerText = prob + '%';
    
    this.toggleConfirmSlider(); 
    
    // Hiển thị modal
    const modal = document.getElementById('med-settings-modal');
    modal.style.display = 'flex';
}

// Cập nhật hàm saveMedSettings
saveMedSettings() {
    this.data.medSettings = {
        mode: 'unified', // Luôn cố định
        holdDuration: parseInt(document.getElementById('inp-hold-time').value),
        vibration: document.getElementById('inp-vibrate').checked,
        confirmMode: document.getElementById('inp-confirm-mode').checked,
        confirmProbability: parseInt(document.getElementById('inp-confirm-prob').value)
    };

    this.save();
}
toggleConfirmSlider() {
    const isChecked = document.getElementById('inp-confirm-mode').checked;
    document.getElementById('confirm-slider-group').style.display = isChecked ? 'block' : 'none';
}


closeMedSettings() {
    this.saveMedSettings();
    document.getElementById('med-settings-modal').style.display = 'none';
}




toggleProModeUI() {
    const isPro = document.getElementById('inp-pro-mode').checked;
    document.getElementById('simple-tap-options').style.display = isPro ? 'none' : 'block';
    document.getElementById('pro-tap-options').style.display = isPro ? 'block' : 'none';
}


// 3. Hàm Helper mới (Thay thế updateConfirmDisplay cũ)
updateConfirmProbDisplay() {
    const val = document.getElementById('inp-confirm-prob').value;
    document.getElementById('disp-confirm-prob').innerText = val + '%';
}

updateMedSettingDisplay() {
    const ms = document.getElementById('inp-hold-time').value;
    document.getElementById('disp-hold-time').innerText = (ms / 1000) + 's';

    this.data.medSettings.holdDuration = parseInt(ms);
}
setDailyMinMedTarget(id) {
    const goal = this.data.goals.find(g => g.id === id);
    if (!goal) return;

    const current = goal.dailyMinMedTarget || 120;
    const input = prompt(`Set daily time goal (minutes) for "${goal.name}":`, current);

    if (input !== null) {
        const val = parseInt(input);
        if (!isNaN(val) && val > 0) {
            goal.dailyMinMedTarget = val;
            this.save();
            this.renderGoals();
            this.showToast(`Updated: ${val} minutes/day`);
        }
    }
}
             renderGoals() {
    const container = document.getElementById('active-goals-container');
    const emptyMsg = document.getElementById('empty-msg');
    container.innerHTML = '';
    if (this.data.goals.length === 0) { emptyMsg.style.display = 'block'; return; }
    emptyMsg.style.display = 'none';
    const todayStr = this.toIsoDate(new Date());

    this.data.goals.forEach(goal => {
        const isMeditation = goal.type === 'meditation';
        const unitLabel = isMeditation ? 'mindfulness' : 'mins';
        const targetProp = isMeditation ? 'totalMindfulness' : 'totalMinutes';
        const overallPct = goal.lifetimeTargetMinutes > 0 ? Math.min((goal[targetProp] / goal.lifetimeTargetMinutes) * 100, 100) : 0;

        // 1. Calculate Today's Primary Value (Counts for Med, Mins for Standard)
        let todayVal = 0;
        if (isMeditation) {
            todayVal = this.data.logs
                .filter(l => l.goalId === goal.id && l.date === todayStr)
                .reduce((sum, l) => sum + (l.count !== undefined ? l.count : (l.touches ? l.touches.length : 0)), 0);
        } else {
            todayVal = this.data.logs.filter(l => l.goalId === goal.id && l.date === todayStr).reduce((sum, l) => sum + l.minutes, 0);
        }
        
        const todayMinutes = this.data.logs
            .filter(l => l.goalId === goal.id && l.date === todayStr)
            .reduce((sum, l) => sum + l.minutes, 0);

        const dailyTarget = goal.dailyTargetMinutes || 0;
		const dailyminmedTarget = goal.dailyMinMedTarget || 120;
        let dailyPct = 0;
        let dailyBarColor = goal.color;
        
        // Calculate percentage for the Primary Bar
        if (dailyTarget > 0) {
            dailyPct = Math.min((todayVal / dailyTarget) * 100, 100);
            if (todayVal >= dailyTarget) dailyBarColor = 'var(--success)';
        }
        
        const div = document.createElement('div');
        div.className = 'card goal-card';
        div.style.borderLeft = `5px solid ${goal.color}`;
        
        let controlsHtml = '', dailySectionHtml = '', sessionSectionHtml = '';
        
        // --- DAILY SECTIONS ---
        if (dailyTarget > 0) {
            dailySectionHtml = `
                <div style="margin-bottom: 10px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
                    <div style="display:flex; justify-content:space-between; font-size:12px; margin-bottom:5px; align-items:center;">
                        <strong style="color:var(--text);">Today's Goal</strong>
                        <span style="font-weight:600;">${todayVal} / ${dailyTarget} ${unitLabel}</span>
                    </div>
                    <div class="progress-container" style="height: 6px;"><div class="progress-bar" style="width: ${dailyPct}%; background: ${dailyBarColor}"></div></div>
                </div>`;

            // 2. NEW BAR (Minutes) - Only for Meditation Goals
            if (isMeditation) {
                const minPct = Math.min((todayMinutes / dailyminmedTarget) * 100, 100);
                let minBarColor = goal.color;
                if (todayMinutes >= dailyminmedTarget) minBarColor = 'var(--success)';

                // CHANGE 2: Added onclick event, cursor pointer, and hover visual cues
                dailySectionHtml += `
                <div 
                    onclick="app.setDailyMinMedTarget('${goal.id}')"
                    title="Edit daily time goal"
                    style="margin-bottom: 15px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; cursor: pointer; transition: background 0.2s;"
                    onmouseover="this.style.background='rgba(0,0,0,0.3)'"
                    onmouseout="this.style.background='rgba(0,0,0,0.2)'"
                >
                    <div style="display:flex; justify-content:space-between; font-size:12px; margin-bottom:5px; align-items:center;">
                        <strong style="color:var(--text);">Daily Time Goal</strong>
                        <span style="font-weight:600;">${todayMinutes} / ${dailyminmedTarget} minutes <i class="fas fa-pen" style="font-size:10px; opacity:0.5; margin-left:4px;"></i></span>
                    </div>
                    <div class="progress-container" style="height: 6px;"><div class="progress-bar" style="width: ${minPct}%; background: ${minBarColor}"></div></div>
                </div>`;
            }
        }

        if (isMeditation) {
            controlsHtml = `
                 <div class="timer-controls">
                    <div style="font-size: 14px; color: var(--text-light); text-transform: uppercase;">Meditation</div>
                    <div style="display:flex; gap: 10px;">
                        <button class="btn-icon btn-play" style="background: var(--zen); color: white;" onclick="app.toggleTimer('${goal.id}')" title="Start Meditate"><i class="fas fa-om"></i></button>
                        
                        <button class="btn-icon" style="background:var(--warning); color:#000;" onclick="app.openSessionModal('${goal.id}')" title="Add Manually"><i class="fas fa-plus"></i></button>
                    </div>
                </div>`;
        } else {
            sessionSectionHtml = `
                            <div class="section-label">Current Session</div>
                            <div class="progress-container"><div id="bar-session-${goal.id}" class="progress-bar" style="background:var(--success); width:0%;"></div></div>
                            <div style="display:flex; justify-content:space-between; font-size:12px; color:var(--text-light);"><span id="prog-text-session-${goal.id}">Ready</span></div>`;
                        controlsHtml = `
                            <div class="timer-controls">
                                <div id="timer-${goal.id}" class="timer-display">00:00</div>
                                <div style="display:flex; gap: 10px;">
                                    <button class="btn-icon ${goal.isActive ? 'btn-stop' : 'btn-play'}" onclick="app.toggleTimer('${goal.id}')"><i class="fas ${goal.isActive ? 'fa-stop' : 'fa-play'}"></i></button>
                                    <button class="btn-icon" style="background:var(--warning); color:#000;" onclick="app.openSessionModal('${goal.id}')"><i class="fas fa-plus"></i></button>
                                </div>
                            </div>`;
                    }

                    div.innerHTML = `
                        <div class="goal-header">
                            <div><div class="goal-title">${goal.name}</div><span class="goal-tag" style="color:#b1b1c9; background: rgba(255,255,255,0.1)">${goal.category}</span></div>
                            <div style="display:flex; gap: 5px;">
                                <button class="btn-icon" style="color: var(--text-light)" onclick="app.openModal('${goal.id}', '${goal.type}')"><i class="fas fa-pencil-alt"></i></button>
                                <button class="btn-icon" style="color: var(--text-light)" onclick="app.deleteGoal('${goal.id}')"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>
                        ${dailySectionHtml}
                        <div class="section-label">Achievement Progress</div>
                        <div class="progress-container"><div class="progress-bar" style="width: ${overallPct}%; background: ${goal.color}"></div></div>
                        <div style="display:flex; justify-content:space-between; font-size:12px; color:var(--text-light); margin-bottom: 15px;"><span>${goal[targetProp]} / ${goal.lifetimeTargetMinutes} ${unitLabel}</span><span>${(overallPct).toFixed(1)}%</span></div>
                        ${sessionSectionHtml} ${controlsHtml}
                        <div class="sessions-list" style="margin-top: 15px; max-height: 150px; overflow-y: auto;"><div id="sessions-${goal.id}"></div></div>
                    `;
                    container.appendChild(div);
                    this.renderSessions(goal.id, isMeditation);
                });
}
            
            renderSessions(goalId, isMeditation) {
                const container = document.getElementById(`sessions-${goalId}`);
                if (!container) return;
                container.innerHTML = '';

                const sessions = this.data.logs.filter(l => l.goalId === goalId).sort((a,b) => b.timestamp - a.timestamp);
                
                if (sessions.length === 0) { 
                    container.innerHTML = '<p style="font-size:12px; color:var(--text-light);">No sessions yet</p>'; 
                    return; 
                }
                
                const ol = document.createElement('ol');
                sessions.forEach((log) => {
                    const sLi = document.createElement('li');
                    sLi.className = 'session-item';
                    
                    const notesDisplay = log.notes ? `<span class="session-notes">"${log.notes}"</span>` : '';

                    let actionButtons = '<div style="display:flex; gap:5px;">';

                    if (isMeditation && log.touches && log.touches.length > 0) {
                        actionButtons += `<button class="btn-icon" style="background:transparent; color:var(--zen); height:24px; width:24px;" onclick="app.showSessionGraph('${log.timestamp}')" title="Show graph"><i class="fas fa-chart-area" style="font-size:12px;"></i></button>`;
                    }

                    actionButtons += `<button class="btn-icon" style="background:transparent; color:var(--text-light); height:24px; width:24px;" onclick="app.openSessionModal('${goalId}', ${log.minutes}, ${log.timestamp}, ${log.timestamp})" title="Edit details"><i class="fas fa-edit" style="font-size:12px;"></i></button>`;
                    
                    actionButtons += '</div>';


                    sLi.innerHTML = `
                        <div class="session-content">
                            <span class="session-date">${this.toDisplayDate(log.timestamp)}</span>: ${log.minutes} minutes 
                            ${notesDisplay}
                        </div>
                        ${actionButtons}
                    `;
                    ol.appendChild(sLi);
                });
                container.appendChild(ol);
            }
            
            showSessionGraph(timestamp) {
    const exportBtn = document.getElementById('btn-export-session');
    if (exportBtn) {
        exportBtn.onclick = () => this.exportSessionData(timestamp);
    }

    const log = this.data.logs.find(l => l.timestamp == timestamp);
    if (!log || !log.touches) {
        this.showToast("No data available for this session");
        return;
    }

    this.currentGraphLog = log;

    document.getElementById('graph-modal').style.display = 'flex';
    document.getElementById('graph-date').innerText = new Date(log.timestamp).toLocaleString('en-GB');

    document.getElementById('graph-type-select').value = 'interval';
    this.updateSessionChart();
}

updateSessionChart() {
    if (!this.currentGraphLog) return;
    const type = document.getElementById('graph-type-select').value;
    const ctx = document.getElementById('sessionGraph').getContext('2d');
    
    if (this.charts.session) this.charts.session.destroy();

    if (type === 'interval') this.renderIntervalChart(ctx, this.currentGraphLog);
    else if (type === 'pro') this.renderProChart(ctx, this.currentGraphLog);
    else this.renderIntensityChart(ctx, this.currentGraphLog);
}

renderProChart(ctx, log) {
    // 1. Calculate Mindfulness vs Distraction
    const analysis = this.analyzeSingleSession(log); 
    const totalSec = log.minutes * 60;
    
    // Distracted Seconds (Thất niệm)
    const distractedSec = analysis.distractedSec;
    const holdDurationSec = (this.data.medSettings.holdDuration || 500) / 1000;
    const recoverySec = (log.awarenessCount || 0) * holdDurationSec;
    // Mindful Seconds (Tỉnh thức)
    const mindfulSec = Math.max(0, totalSec - distractedSec - recoverySec);

    // 2. Count Pro Touches
    const counts = { 1: 0, 2: 0, 3: 0, 4: 0 };
    let proCount = 0;
    
    if (log.touches && log.touches.length > 0) {
        log.touches.forEach(t => {
            if (t.v) {
                counts[t.v]++;
                proCount++;
            }
        });
    }

    // 3. Distribute Mindful Time
    // We use key '0' for Standard/Basic mindfulness (No Pro data)
     const dataSeconds = { 1: 0, 2: 0, 3: 0, 4: 0 };

    
        dataSeconds[1] = (counts[1] / proCount) * mindfulSec;
        dataSeconds[2] = (counts[2] / proCount) * mindfulSec;
        dataSeconds[3] = (counts[3] / proCount) * mindfulSec;
        dataSeconds[4] = (counts[4] / proCount) * mindfulSec;
   
// --- NEW: Calculate Average Score for Title ---
    let titleText = `Total duration: ${log.minutes} minutes`;
    let titleWeight = 'normal';
    let titleColor = '#9ca3af';

    if (proCount > 0) {
        // Weighted Sum: Level 1 (Cao)=4, Level 2 (Tốt)=3, Level 3 (TB)=2, Level 4 (Thấp)=1
        const weightedSum = (counts[1] * 4) + (counts[2] * 3) + (counts[3] * 2) + (counts[4] * 1);
        const averageScore = (weightedSum / proCount).toFixed(2);
        
        titleText = `Average focus level: ${averageScore} / 4.0`;
        titleWeight = '600';
        titleColor = '#f3f4f6';
    }
    // 4. Define Colors & Labels
    const qualities = {
        1: { label: 'High', color: '#34d399' },      // Green
        2: { label: 'Good', color: '#60a5fa' },      // Blue
        3: { label: 'Medium', color: '#fbbf24' },       // Yellow
        4: { label: 'Low', color: '#f87171' },     // Red
        0: { label: 'Alertness',  color: '#a78bfa' },      // Purple (New Standard Level)
        5: { label: 'Distraction', color: '#6b7280' }     // Gray (Updated from White)
    };

    // 5. Cleanup Old Chart
    if (this.charts.session) this.charts.session.destroy();

    // 6. Render Chart
    this.charts.session = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Meditation Session'],
            datasets: [
                // Only show Pro levels if Pro data exists, otherwise show Basic
               
                    {
                        label: qualities[1].label,
                        data: [dataSeconds[1]],
                        backgroundColor: qualities[1].color,
                        barPercentage: 0.6,
                        borderRadius: { topLeft: 8, bottomLeft: 8 }
                    },
                    {
                        label: qualities[2].label,
                        data: [dataSeconds[2]],
                        backgroundColor: qualities[2].color,
                        barPercentage: 0.6
                    },
                    {
                        label: qualities[3].label,
                        data: [dataSeconds[3]],
                        backgroundColor: qualities[3].color,
                        barPercentage: 0.6
                    },
                    {
                        label: qualities[4].label,
                        data: [dataSeconds[4]],
                        backgroundColor: qualities[4].color,
                        barPercentage: 0.6
                    },
					{
                        label: qualities[0].label,
                        data: [recoverySec],
                        backgroundColor: qualities[0].color,
                        barPercentage: 0.6,
                        borderRadius: { topLeft: 8, bottomLeft: 8 }
                    },
               
                {
                    label: qualities[5].label,
                    data: [distractedSec],
                    backgroundColor: qualities[5].color,
                    barPercentage: 0.6,
                    borderRadius: { topRight: 8, bottomRight: 8 }
                },
            ]
        },
        options: {
            indexAxis: 'y', // Horizontal
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    display: true, 
                    max: totalSec, 
					grid: {
            color: 'rgba(156, 163, 175, 0.1)' // Light grid lines to match theme
        },
        ticks: {
            color: '#9ca3af',
            // This function converts the seconds value to a minute label
            callback: function(value) {
                return (value / 60).toFixed(0) + 'p';
            }
        }
    },
                
                y: {
                    stacked: true,
                    display: false 
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        color: '#9ca3af',
                        usePointStyle: true,
                        padding: 20,
                        font: { size: 11 },
                        generateLabels: function(chart) {
                            const data = chart.data;
                            return data.datasets.map((dataset, i) => {
                                const val = dataset.data[0];
                                const pct = totalSec > 0 ? ((val / totalSec) * 100).toFixed(1) : 0;
                                const isHidden = !chart.isDatasetVisible(i);
                                return {
                                    text: `${dataset.label}: ${pct}%`,
                                    fillStyle: dataset.backgroundColor,
                                    strokeStyle: 'transparent',
                                    fontColor: isHidden ? '#6b7280' : '#9ca3af',
                                    pointStyle: 'circle',
                                    datasetIndex: i,
                                    hidden: isHidden
                                };
                            });
                        }
                    }
                },
                tooltip: {
                    backgroundColor: '#1f2937',
                    titleColor: '#f3f4f6',
                    bodyColor: '#f3f4f6',
                    borderColor: '#374151',
                    borderWidth: 1,
                    padding: 10,
                    callbacks: {
                        title: () => null,
                        label: function(context) {
                            const val = context.raw;
                            const pct = totalSec > 0 ? ((val / totalSec) * 100).toFixed(1) : 0;
                            let timeStr = "";
                            if (val < 60) timeStr = Math.round(val) + "s";
                            else timeStr = (val/60).toFixed(1) + "m";
                            
                            const rawLabel = context.dataset.label;

                            // IF Level 0 (Cơ bản) OR Level 5 (Thất niệm) -> Show label as is
                            if (rawLabel.includes('Mindfulness') || rawLabel.includes('Distraction')) {
                                return `${rawLabel}: ${pct}% (${timeStr})`;
                            } 
                            
                            // ELSE (Levels 1-4) -> Add prefix and lowercase
                            return `Focus level: ${rawLabel} - ${pct}% (${timeStr})`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: titleText,
                    color: titleColor,
                    font: { size: 13, style: 'italic', weight: titleWeight },
                    padding: { bottom: 10 }
                }
            }
        }
    });
}
renderIntensityChart(ctx, log) {
    const startTime = log.timestamp;
    const durationSeconds = (log.minutes * 60) || Math.ceil((Date.now() - startTime) / 1000);
    
    const dataPoints = [];
    const labels = [];
    const totalPoints = 30; 
    const step = durationSeconds / totalPoints; 

    for (let s = 0; s <= durationSeconds; s += step) {
        labels.push(durationSeconds < 120 ? Math.round(s) + 's' : (s / 60).toFixed(0));
        const windowSizeMs = 60000; 
        const windowStart = (s * 1000) - (windowSizeMs / 2);
        const windowEnd = (s * 1000) + (windowSizeMs / 2);

        const intensity = log.touches.filter(t => {

            const touchTime = this.getTouchTimestamp(t, log.timestamp) - startTime;
            return touchTime >= windowStart && touchTime <= windowEnd;
        }).length;
        dataPoints.push(intensity);
    }

    const chartHeight = ctx.canvas.clientHeight || 300; 
    const gradient = ctx.createLinearGradient(0, 0, 0, chartHeight);
    gradient.addColorStop(0, 'rgba(167, 139, 250, 0.6)'); 
    gradient.addColorStop(0.5, 'rgba(167, 139, 250, 0.3)'); 
    gradient.addColorStop(1, 'rgba(167, 139, 250, 0.05)');   

    this.charts.session = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Mindfulness',
                data: dataPoints,
                borderColor: '#a78bfa', 
                backgroundColor: gradient,
                borderWidth: 3,
                fill: true,
                tension: 0.4,
                pointRadius: 0,
                pointHoverRadius: 5,
                pointBackgroundColor: '#c7b6fc',
                pointBorderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            scales: {
                x: { title: { display: true, font: { size: 11 }, text: 'Time (mins)', color: '#9ca3af' }, grid: { display: true }, ticks: { maxTicksLimit: 20, color: '#9ca3af' } },
                y: { beginAtZero: true, title: { display: true, font: { size: 11 }, text: 'Mindfulness counts', color: '#9ca3af', padding: 0.1, }, grid: { color: 'rgba(55, 65, 81, 0.5)' }, ticks: { color: '#9ca3af', precision: 0, } }},
            plugins: {
                tooltip: {
                    mode: 'index', intersect: false, displayColors: false,
                    callbacks: {title: () => '',  label: (c) => c.raw >= 1 ? "🌱 Mindfulness (" + c.raw + ")" : "☁️ Unmindful" }
                },
                legend: { display: false }
            }
        }
    });
}

renderIntervalChart(ctx, log) {

    const timestamps = log.touches
        .map(t => this.getTouchTimestamp(t, log.timestamp))
        .sort((a, b) => a - b);
        
    const startTime = log.timestamp;

    const dataPoints = [];
    const labels = [];
    let previousTime = startTime;

    timestamps.forEach(t => {
        const gapSeconds = (t - previousTime) / 1000;
        const timeFromStartMins = ((t - startTime) / 1000 / 60).toFixed(0);
        
        dataPoints.push(gapSeconds.toFixed(1));
        labels.push(timeFromStartMins);
        previousTime = t;
    });

    const endTime = startTime + (log.minutes * 60 * 1000);
    if (endTime > previousTime) {
        const finalGap = (endTime - previousTime) / 1000;
        dataPoints.push(finalGap.toFixed(1));
        labels.push(log.minutes.toFixed(1));
    }

    const chartHeight = ctx.canvas.clientHeight || 300;
    const gradient = ctx.createLinearGradient(0, 0, 0, chartHeight);
    gradient.addColorStop(0, 'rgba(248, 113, 113, 0.6)'); 
    gradient.addColorStop(0.5, 'rgba(248, 113, 113, 0.3)'); 
    gradient.addColorStop(1, 'rgba(248, 113, 113, 0.05)'); 

    this.charts.session = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels, 
            datasets: [{
                label: 'Forgetfulness Interval',
                data: dataPoints,
                borderColor: '#f87171', 
                backgroundColor: gradient,
                borderWidth: 2,
                fill: true,
                tension: 0.2, 
                pointRadius: 0,
                pointBackgroundColor: '#f87171',
                pointHoverRadius: 4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            scales: {
                x: { 
                    title: { display: true, text: 'Time (mins)', color: '#9ca3af', font: { size: 11 } }, 
                    grid: { display: true }, 
                    ticks: { color: '#9ca3af', maxTicksLimit: 15 } 
                },
                y: { 
                    beginAtZero: true, 
                    title: { display: true, text: 'Delays', color: '#9ca3af', padding: 0.1, font: { size: 11 } }, 
                    ticks: { color: '#9ca3af' } 
                }
            },
            plugins: {
                tooltip: {
                    displayColors: false,
                    callbacks: {
                        title: (items) => `Minute ${items[0].label}`,
                        label: (c) => `Delay: ${c.raw} secs`
                    }
                },
                legend: { display: false }
            }
        }
    });
}

exportSessionData(timestamp) {
    const log = this.data.logs.find(l => l.timestamp == timestamp);
    if (!log) {
        this.showToast('Could not copy text!');
        return;
    }

    const dataStr = JSON.stringify(log);

    if (navigator.clipboard) {
        navigator.clipboard.writeText(dataStr).then(() => {
            this.showToast('JSON data has been copied!');
        }).catch((err) => {
            console.error('Async: Could not copy text: ', err);
            this.fallbackCopyText(dataStr);
        });
    } else {
        this.fallbackCopyText(dataStr);
    }
}

fallbackCopyText(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;

    textArea.style.position = 'fixed';
    textArea.style.left = '-9999px';
    document.body.appendChild(textArea);
    
    textArea.focus();
    textArea.select();
    
    try {
        const successful = document.execCommand('copy');
        if(successful) this.showToast('JSON data has been copied!');
        else this.showToast('Oops, unable to copy');
    } catch (err) {
        console.error('Fallback: Oops, unable to copy', err);
        this.showToast('Oops, unable to copy');
    }

    
    document.body.removeChild(textArea);
}
            openChoiceModal() { document.getElementById('choice-modal').style.display = 'flex'; }
            closeChoiceModal() { document.getElementById('choice-modal').style.display = 'none'; }

            openModal(goalId = null, type = 'standard') { 
                this.closeChoiceModal(); 
                const modal = document.getElementById('goal-modal');
                const title = document.getElementById('modal-title');
                const btn = document.getElementById('btn-save-goal');
                const catSelect = document.getElementById('g-cat');
                catSelect.innerHTML = '';
                const cats = type === 'meditation' ? ['Sitting', 'Walking', 'Contemplation', 'Bhavana'] : ['Work', 'Study', 'Health', 'Creative', 'Merit', 'Other'];
                cats.forEach(c => { const opt = document.createElement('option'); opt.value = c; opt.innerText = c; catSelect.appendChild(opt); });

                const dailyHint = document.getElementById('g-daily-hint');
                const lifeHint = document.getElementById('g-life-hint');
                if (type === 'meditation') { dailyHint.innerText = "Mindfulness per day"; lifeHint.innerText = "Mindfulness"; } 
                else { dailyHint.innerText = "Mins per day"; lifeHint.innerText = "Minutes"; }
                document.getElementById('g-type').value = type;

                if (goalId) {
                    const goal = this.data.goals.find(g => g.id === goalId);
                    if (goal) {
                        document.getElementById('g-id').value = goal.id;
                        document.getElementById('g-name').value = goal.name;
                        document.getElementById('g-cat').value = goal.category;
                        document.getElementById('g-color').value = goal.color;
                        document.getElementById('g-lifetime-target').value = goal.lifetimeTargetMinutes;
                        document.getElementById('g-daily-target').value = goal.dailyTargetMinutes;
                        document.getElementById('g-type').value = goal.type || 'standard';
                        title.innerText = 'Edit Goal'; btn.innerText = 'Save';
                    }
                } else {
                    document.getElementById('g-id').value = '';
                    document.getElementById('g-name').value = '';
                    document.getElementById('g-color').value = type === 'meditation' ? '#a78bfa' : '#818cf8';
                    document.getElementById('g-lifetime-target').value = 1000;
                    document.getElementById('g-daily-target').value = 100;
                    title.innerText = type === 'meditation' ? 'New Meditation Goal' : 'New Activity Goal'; btn.innerText = 'Create';
                }
                modal.style.display = 'flex'; 
            }
            closeModal() { document.getElementById('goal-modal').style.display = 'none'; }
            
                        renderCalendar() {
                const grid = document.getElementById('calendar-grid');
                grid.innerHTML = '';
                const y = this.currentMonth.getFullYear(); const m = this.currentMonth.getMonth();
                document.getElementById('cal-month-year').innerText = new Date(y, m).toLocaleString('en-GB', { month: 'long', year: 'numeric' });

                const headerDiv = document.createElement('div');
                headerDiv.className = 'calendar-header';
                ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'].forEach(d => {
                    const h = document.createElement('div'); h.className = 'cal-head-day'; h.innerText = d;
                    grid.appendChild(h);
                });

                const firstDayRaw = new Date(y, m, 1).getDay();

                const blankSlots = firstDayRaw === 0 ? 6 : firstDayRaw - 1;

                const daysInMonth = new Date(y, m + 1, 0).getDate();
                
                for(let i=0; i<blankSlots; i++) { grid.appendChild(document.createElement('div')); }
                for(let i=1; i<=daysInMonth; i++) {
                    const dStr = `${y}-${String(m+1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                    const dayEl = document.createElement('div');
                    dayEl.className = 'calendar-day'; dayEl.innerText = i;
                    const totalMins = this.data.logs.filter(l => l.date === dStr).reduce((sum, l) => sum + l.minutes, 0);
if(totalMins > 0) {
    dayEl.classList.add('has-data');

    if (totalMins >= 240) dayEl.classList.add('level-8');      
    else if (totalMins >= 180) dayEl.classList.add('level-7'); 
    else if (totalMins >= 150) dayEl.classList.add('level-6'); 
    else if (totalMins >= 120) dayEl.classList.add('level-5'); 
    else if (totalMins >= 90) dayEl.classList.add('level-4');  
    else if (totalMins >= 60) dayEl.classList.add('level-3');  
    else if (totalMins >= 30) dayEl.classList.add('level-2');  
    else dayEl.classList.add('level-1');                     
}
     
                    dayEl.onclick = () => this.openDayStats(dStr);
                    grid.appendChild(dayEl);
                               }
				const quoteBox = document.getElementById('dhammapada-display');
    if (quoteBox && !quoteBox.hasAttribute('data-loaded')) {
        this.renderRandomQuote();
    }
            }
renderRandomQuote() {
    const display = document.getElementById('dhammapada-display');
    const sourceDisplay = document.getElementById('dhammapada-source'); 
    
    if (!display) return;

    display.style.opacity = '0';
    if(sourceDisplay) sourceDisplay.style.opacity = '0';

    setTimeout(() => {

        const randomIndex = Math.floor(Math.random() * DHAMMAPADA.length);
        const verse = DHAMMAPADA[randomIndex];

        display.innerHTML = verse.t;

        if (sourceDisplay) {

            sourceDisplay.innerText = `Dhammapada ${randomIndex + 1}`;
            sourceDisplay.style.opacity = '0.7'; 
        }

        display.setAttribute('data-loaded', 'true');

        display.style.opacity = '1';
    }, 200); 
}
switchDayChart(mode) {
    this.dayChartMode = mode;

    const btnTime = document.getElementById('btn-modal-time');
    const btnMind = document.getElementById('btn-modal-mind');
    
    if (mode === 'time') {
        btnTime.className = 'btn';
        btnMind.className = 'btn btn-secondary';
    } else {
        btnTime.className = 'btn btn-secondary';
        btnMind.className = 'btn';
    }

    if (this.currentViewDate) {
        this.renderDayChartOnly(this.currentViewDate);
    }
}
openDayStats(dateStr) {
    this.currentViewDate = dateStr;
    const modal = document.getElementById('day-details-modal');
    document.getElementById('day-modal-title').innerText = new Date(dateStr).toLocaleDateString('en-GB', {weekday: 'long', day: 'numeric', month: 'numeric'});

    this.switchDayChart('time'); 

    const dayLogs = this.data.logs.filter(l => l.date === dateStr).sort((a,b) => b.timestamp - a.timestamp);
    const listContainer = document.getElementById('day-session-list');
    listContainer.innerHTML = dayLogs.length ? '' : '<p class="empty-state">No Activities.</p>';
    
    const ul = document.createElement('ul'); 
    ul.style.listStyle = 'none';
    
    dayLogs.forEach(log => {
        const goal = this.data.goals.find(g => g.id === log.goalId);
        const li = document.createElement('li');
        li.style.cssText = 'padding: 8px 0; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; font-size: 13px; align-items:center;';

        let graphBtnHtml = '';
        if (goal && goal.type === 'meditation' && log.touches && log.touches.length > 0) {
            graphBtnHtml = `<button class="btn-icon" style="background:transparent; color:var(--zen); height:24px; width:24px; margin-right:5px; cursor:pointer;" onclick="app.showSessionGraph('${log.timestamp}')"><i class="fas fa-chart-area" style="font-size:12px;"></i></button>`;
        }

        const satiCount = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);
        const satiInfo = satiCount > 0 ? `<span style="color: var(--zen); font-size: 11px; margin-left: 5px; font-weight:bold;">(${satiCount} Mindfulness)</span>` : '';

        const leftSide = `<div>
                           <span style="font-weight:600; color:${goal?goal.color:'#ccc'}">${goal?goal.name:'Deleted'}</span>
                           <span style="margin-left:5px;">${log.minutes}m</span>
                           ${satiInfo}
                         </div>`;
        
        const rightSide = `<div style="display:flex; align-items:center;">
                               ${graphBtnHtml}
                               <div style="font-size: 11px; color: var(--text-light); width:35px; text-align:right;">
                                   ${new Date(log.timestamp).toLocaleTimeString('en-GB', {hour: '2-digit', minute:'2-digit'})}
                               </div>
                           </div>`;

        li.innerHTML = leftSide + rightSide;
        ul.appendChild(li);
    });
    listContainer.appendChild(ul);
    
    modal.style.display = 'flex';
}

renderDayChartOnly(dateStr) {
    const ctx = document.getElementById('dayBreakdownChart').getContext('2d');
    const isMindfulness = this.dayChartMode === 'mindfulness';
    const unitLabel = isMindfulness ? 'Mindfulness' : 'Minutes';

    const dayLogs = this.data.logs.filter(l => l.date === dateStr);
    const goalStats = {};

    dayLogs.forEach(log => {
        if (isMindfulness) {
             const val = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);
             if (val === 0) return;
        }

        if(!goalStats[log.goalId]) {
            const goal = this.data.goals.find(g => g.id === log.goalId);
            goalStats[log.goalId] = { 
                name: goal ? goal.name : 'Deleted', 
                color: goal ? goal.color : '#ccc', 
                value: 0 
            };
        }
        
        if (isMindfulness) {
            goalStats[log.goalId].value += (log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0));
        } else {
            goalStats[log.goalId].value += log.minutes;
        }
    });

    if(this.charts.dayChart) this.charts.dayChart.destroy();
    
    const dataValues = Object.values(goalStats).map(s => s.value);

    const centerTextPlugin = {
        id: 'centerText',
        afterDatasetsDraw: function(chart) {
            const { ctx, chartArea: { top, bottom, left, right } } = chart;
            
            ctx.save();

            let total = 0;
            const data = chart.data.datasets[0].data;
            if(data.length > 0) {
                data.forEach(val => total += val);
            }

            let mainText = "";
            if (!isMindfulness) {
                // Hour/Minute logic
                if (total < 60) {
                    mainText = total + "m";
                } else {
                    mainText = (total / 60).toFixed(1) + "h";
                }
            } else {
                mainText = total.toLocaleString(); 
            }

            const centerX = (left + right) / 2;
            const centerY = (top + bottom) / 2;

            const chartHeight = bottom - top;
            const fontSizeMain = chartHeight / 10; // Larger for the number
            const fontSizeSub = chartHeight / 20;  // Smaller for the label

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (isMindfulness) {
                // --- LINE 1: The Value (White/Bold) ---
                ctx.font = `bold ${fontSizeMain}px sans-serif`;
                ctx.fillStyle = "#FFFFFF"; 
                // Offset slightly upwards
                ctx.fillText(mainText, centerX, centerY - (fontSizeMain * 0.15));

                // --- LINE 2: The Unit Label (Gray/Normal) ---
                ctx.font = `normal ${fontSizeSub}px sans-serif`;
                ctx.fillStyle = "#9ca3af"; 
                // Offset slightly downwards
                ctx.fillText(unitLabel, centerX, centerY + (fontSizeMain * 0.65));
           } else {
            // --- TIME MODE: Only draw the number in the center ---
            ctx.font = `bold ${fontSizeMain}px sans-serif`;
            ctx.fillStyle = "#FFFFFF"; 
            ctx.fillText(mainText, centerX, centerY); 
        }

        ctx.restore();
    }
};
    this.charts.dayChart = new Chart(ctx, {
        type: 'doughnut',
        data: { 
            labels: Object.values(goalStats).map(s => s.name), 
            datasets: [{ 
                data: dataValues, 
                backgroundColor: Object.values(goalStats).map(s => s.color), 
                borderWidth: 1, 
                borderColor: '#1f2937' 
            }] 
        },
        options: { 
        maintainAspectRatio: false, 
        plugins: { 
            legend: { 
                position: 'right', 
                labels: { color: '#9ca3af', font: {size: 11} } 
            },
            title: { 
                display: dataValues.length === 0, 
                text: 'No data available', 
                position: 'bottom', 
                color: '#6b7280' 
            },
            tooltip: {
				backgroundColor: '#121821', // Màu Solid (Hex) trùng với var(--surface), chắn hoàn toàn chữ bên dưới
                titleColor: '#f3f4f6',      // Màu chữ sáng (var(--text))
                bodyColor: '#f3f4f6',
                borderColor: '#374151',     // Viền xám (var(--border)) để tooltip nổi bật hơn
                borderWidth: 1,
                padding: 10,
				z: 999,
                callbacks: {
                    label: function(context) {
                        const value = context.raw || 0;
                        
                        // 1. Calculate the total sum of the dataset
                        const total = context.dataset.data.reduce((acc, curr) => acc + curr, 0);
                        
                        // 2. Calculate percentage (prevent division by zero)
                        const percentage = total > 0 ? ((value / total) * 100).toFixed(0) : 0;

                        // 3. Return the formatted string
                        if (!isMindfulness) {
                            return ` ${value} ${unitLabel} (${percentage}%)`;
                        }
                        return ` ${value} ${unitLabel} (${percentage}%)`;
                    }
                }
            }
        } 
    },
        plugins: [centerTextPlugin]
    });
}
            closeDayModal() { document.getElementById('day-details-modal').style.display = 'none'; }
setReportMode(mode) {
    this.reportMode = mode;

    const btnTime = document.getElementById('btn-rep-time');
    const btnMind = document.getElementById('btn-rep-mind');
    
    if (mode === 'time') {
        btnTime.className = 'btn'; 
        btnMind.className = 'btn btn-secondary';
    } else {
        btnTime.className = 'btn btn-secondary';
        btnMind.className = 'btn'; 
    }

    this.renderReports();
}

renderReports(resetDates = false) {
    if (!document.getElementById('weeklyChart')) return;

    const isMindfulness = this.reportMode === 'mindfulness';
    const unitLabel = isMindfulness ? 'Logs' : 'Minutes'; // Đổi đơn vị hiển thị

    document.getElementById('breakdown-title').innerText = isMindfulness ? 'Mindfulness Chart' : 'Time Chart';

    const rangeSelect = document.getElementById('report-range-select');
    const rangeMode = rangeSelect ? rangeSelect.value : 'all';

    const now = new Date();
    const realCurrentDay = now.getDay() || 7;
    const realThisWeekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - realCurrentDay + 1);
    const realThisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);

    // --- Xử lý Reset ngày tháng khi đổi filter ---
    if (resetDates) {
        if (rangeMode === 'last_week') {
            this.currentWeekStart = new Date(realThisWeekStart);
            this.currentWeekStart.setDate(this.currentWeekStart.getDate() - 7);
            this.currentMonth = new Date(this.currentWeekStart.getFullYear(), this.currentWeekStart.getMonth(), 1);
        } else if (rangeMode === 'last_month') {
            this.currentMonth = new Date(realThisMonthStart);
            this.currentMonth.setMonth(this.currentMonth.getMonth() - 1);
            this.currentWeekStart = this.getStartOfWeek(new Date(this.currentMonth.getFullYear(), this.currentMonth.getMonth(), 1));
        } else if (rangeMode === 'this_week' || rangeMode === 'this_month' || rangeMode === 'today') {
            this.currentWeekStart = new Date(realThisWeekStart);
            this.currentMonth = new Date(realThisMonthStart);
        }
    }

    // --- Định nghĩa khoảng thời gian Filter cho biểu đồ Tròn ---
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
    let filterStart = 0;
    let filterEnd = Date.now() + 86400000;

    if (rangeMode === 'today') filterStart = todayStart;
    else if (rangeMode === 'yesterday') {
        filterEnd = todayStart;
        filterStart = todayStart - 86400000;
    } else if (rangeMode === 'this_week') {
        filterStart = realThisWeekStart.getTime();
    } else if (rangeMode === 'last_week') {
        filterEnd = realThisWeekStart.getTime();
        filterStart = realThisWeekStart.getTime() - (7 * 24 * 60 * 60 * 1000);
    } else if (rangeMode === 'this_month') {
        filterStart = realThisMonthStart.getTime();
    } else if (rangeMode === 'last_month') {
        filterEnd = realThisMonthStart.getTime();
        filterStart = new Date(now.getFullYear(), now.getMonth() - 1, 1).getTime();
    }

    // --- Định nghĩa khoảng thời gian cho biểu đồ Tuần/Tháng ---
    const weekStartMs = this.currentWeekStart.getTime();
    const weekEndMs = weekStartMs + (7 * 24 * 60 * 60 * 1000);
    const weekEndDisp = new Date(weekEndMs - 1);
    document.getElementById('weekly-report-title').innerText = `Week (${this.currentWeekStart.toLocaleDateString('en-GB', {month:'numeric', day:'numeric'})} - ${weekEndDisp.toLocaleDateString('en-GB', {month:'numeric', day:'numeric'})})`;

    const mYear = this.currentMonth.getFullYear();
    const mMonth = this.currentMonth.getMonth();
    const monthlyLabels = Array.from({ length: new Date(mYear, mMonth + 1, 0).getDate() }, (_, i) => i + 1);
    document.getElementById('monthly-report-title').innerText = `Month ${new Date(mYear, mMonth).toLocaleDateString('en-GB', { month: 'numeric', year: 'numeric' })}`;

    // --- CHUẨN BỊ DỮ LIỆU ---
    let datasets = [];

    if (isMindfulness) {
        // === CHẾ ĐỘ CHÁNH NIỆM: GỘP TOÀN BỘ GOAL, CHIA THEO LOẠI TÂM ===
        // Tạo 2 nhóm dữ liệu cố định
        const mindData = {
            id: 'mindfulness', name: 'Mindfulness', color: '#34d399', // Xanh ngọc
            breakdownTotal: 0, weekly: new Array(7).fill(0), monthly: new Array(monthlyLabels.length).fill(0)
        };
        const awareData = {
            id: 'awareness', name: 'Alertness', color: '#818cf8', // Tím
            breakdownTotal: 0, weekly: new Array(7).fill(0), monthly: new Array(monthlyLabels.length).fill(0)
        };

        this.data.logs.forEach(log => {
            // Lấy thời gian log
            let logTime = log.timestamp;
            let logDateObj;
            if (!logTime) { logDateObj = new Date(log.date); logTime = logDateObj.getTime(); }
            else { logDateObj = new Date(logTime); }

            // Lấy giá trị Chánh niệm & Tỉnh giác
            const countVal = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);
            const awareVal = log.awarenessCount || 0;

            // 1. Cộng tổng cho biểu đồ Tròn (theo filter range)
            if (logTime >= filterStart && logTime < filterEnd) {
                mindData.breakdownTotal += countVal;
                awareData.breakdownTotal += awareVal;
            }

            // 2. Cộng vào biểu đồ Tuần
            if (logTime >= weekStartMs && logTime < weekEndMs) {
                let dayIdx = logDateObj.getDay();
                dayIdx = (dayIdx === 0 ? 6 : dayIdx - 1);
                mindData.weekly[dayIdx] += countVal;
                awareData.weekly[dayIdx] += awareVal;
            }

            // 3. Cộng vào biểu đồ Tháng
            if (logDateObj.getFullYear() === mYear && logDateObj.getMonth() === mMonth) {
                mindData.monthly[logDateObj.getDate() - 1] += countVal;
                awareData.monthly[logDateObj.getDate() - 1] += awareVal;
            }
        });

        datasets = [mindData, awareData];

    } else {
        // === CHẾ ĐỘ THỜI GIAN: CHIA THEO MỤC TIÊU (GOAL) ===
        const goalDatasets = {};
        this.data.goals.forEach(goal => {
            goalDatasets[goal.id] = {
                name: goal.name, color: goal.color,
                breakdownTotal: 0, weekly: new Array(7).fill(0), monthly: new Array(monthlyLabels.length).fill(0)
            };
        });

        this.data.logs.forEach(log => {
            if (!goalDatasets[log.goalId]) return;

            const value = log.minutes; // Lấy số phút
            let logTime = log.timestamp;
            let logDateObj;
            if (!logTime) { logDateObj = new Date(log.date); logTime = logDateObj.getTime(); }
            else { logDateObj = new Date(logTime); }

            if (logTime >= filterStart && logTime < filterEnd) {
                goalDatasets[log.goalId].breakdownTotal += value;
            }
            if (logTime >= weekStartMs && logTime < weekEndMs) {
                let dayIdx = logDateObj.getDay();
                dayIdx = (dayIdx === 0 ? 6 : dayIdx - 1);
                goalDatasets[log.goalId].weekly[dayIdx] += value;
            }
            if (logDateObj.getFullYear() === mYear && logDateObj.getMonth() === mMonth) {
                goalDatasets[log.goalId].monthly[logDateObj.getDate() - 1] += value;
            }
        });
        datasets = Object.values(goalDatasets);
    }

    // Lọc dữ liệu hiển thị
    // Biểu đồ tròn: Chỉ hiện những cái > 0
    const activeDataForDoughnut = datasets.filter(d => d.breakdownTotal > 0);
    // Biểu đồ cột: Hiện tất cả (hoặc lọc nếu muốn gọn)
    const allDataForBars = datasets; 

    const weekDays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

    // --- CẤU HÌNH CHART CHUNG ---
    const commonOptions = {
        maintainAspectRatio: false,
        scales: {
            x: { stacked: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af', font: { size: 11 } } },
            y: {
                stacked: true,
                grid: { color: '#374151' },
                title: { display: false },
                ticks: { color: '#9ca3af', font: { size: 11 } }
            }
        },
        plugins: {
            legend: { labels: { color: '#9ca3af', font: { size: 11 } } },
            tooltip: {
                
                callbacks: {
                    label: function(context) {
                        let label = context.dataset.label || '';
                        let value = context.raw || 0;
                        let total = 0;
                        
                        // Calculate the total of the stack (Sum of all visible datasets at this index)
                        context.chart.data.datasets.forEach((dataset, i) => {
                            if (context.chart.isDatasetVisible(i)) {
                                total += dataset.data[context.dataIndex] || 0;
                            }
                        });

                        // Calculate percentage
                        let percentage = total > 0 ? ((value / total) * 100).toFixed(0) : 0;
                        
                        // Format the value (Minutes vs Hours)
                        let formattedValue = "";
                        if (unitLabel === 'Minutes') {
                            if (value < 60) formattedValue = value + " minutes";
                            else formattedValue = (value / 60).toFixed(1) + " hours";
                        } else {
                            formattedValue = value.toLocaleString() + " " + unitLabel;
                        }
                        
                        return `${label}: ${formattedValue} (${percentage}%)`;
                    }
                }
            }
        }
    };

    // --- VẼ BIỂU ĐỒ TRÒN (BREAKDOWN) ---
    const ctxBreakdown = document.getElementById('goalBreakdownChart').getContext('2d');
    if (this.charts.breakdown) this.charts.breakdown.destroy();

    const centerTextPlugin = {
        id: 'centerText',
        afterDatasetsDraw: function(chart) {
            const { ctx, chartArea: { top, bottom, left, right } } = chart;
            ctx.save();
            let total = 0;
            const data = chart.data.datasets[0].data;
            data.forEach(val => total += val);

            let mainText = "";
            let currentUnit = typeof unitLabel !== 'undefined' ? unitLabel : '';

            if (currentUnit === 'Minutes') {
                if (total < 60) mainText = total + "m";
                else mainText = (total / 60).toFixed(1) + "h";
            } else {
                mainText = total.toLocaleString();
            }

            const centerX = (left + right) / 2;
            const centerY = (top + bottom) / 2;
            const chartHeight = bottom - top;
            const fontSizeMain = chartHeight / 13;
            const fontSizeSub = chartHeight / 26;

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            if (isMindfulness) {
                ctx.font = `bold ${fontSizeMain}px sans-serif`;
                ctx.fillStyle = "#FFFFFF";
                ctx.fillText(mainText, centerX, centerY - (fontSizeMain * 0.15));
                ctx.font = `normal ${fontSizeSub}px sans-serif`;
                ctx.fillStyle = "#9ca3af";
                ctx.fillText("Logs", centerX, centerY + (fontSizeMain * 0.65));
            } else {
                ctx.font = `bold ${fontSizeMain}px sans-serif`;
                ctx.fillStyle = "#FFFFFF";
                ctx.fillText(mainText, centerX, centerY);
            }
            ctx.restore();
        }
    };

    this.charts.breakdown = new Chart(ctxBreakdown, {
        type: 'doughnut',
        data: {
            labels: activeDataForDoughnut.map(d => d.name),
            datasets: [{
                data: activeDataForDoughnut.map(d => d.breakdownTotal),
                backgroundColor: activeDataForDoughnut.map(d => d.color),
                borderWidth: 1, borderColor: '#1f2937'
            }]
        },
        options: {
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { color: '#9ca3af' } },
                title: { display: activeDataForDoughnut.length === 0, text: 'No data available', position: 'bottom', color: '#6b7280' },
                tooltip: {
                    backgroundColor: '#121821', titleColor: '#f3f4f6', bodyColor: '#f3f4f6', borderColor: '#374151', borderWidth: 1, padding: 10, z: 999,
                    callbacks: {
                        label: function(context) {
                            let value = context.raw;
                            let formattedValue = "";
                            const total = context.dataset.data.reduce((acc, curr) => acc + curr, 0);
                            const percentage = total > 0 ? ((value / total) * 100).toFixed(0) : 0;
                            if (unitLabel === 'Minutes') {
                                if (value < 60) formattedValue = value + " minutes";
                                else formattedValue = (value / 60).toFixed(1) + " hours";
                            } else {
                                formattedValue = value.toLocaleString() + " " + unitLabel;
                            }
                            return ` ${formattedValue} (${percentage}%)`;
                        }
                    }
                }
            }
        },
        plugins: [centerTextPlugin]
    });

    // --- VẼ BIỂU ĐỒ TUẦN ---
    const ctxWeek = document.getElementById('weeklyChart').getContext('2d');
    if (this.charts.weekly) this.charts.weekly.destroy();

    const weeklyOptions = {
        ...commonOptions,
        plugins: {
            ...commonOptions.plugins,
            tooltip: {
                ...commonOptions.plugins.tooltip,
                callbacks: {
                    ...commonOptions.plugins.tooltip.callbacks,
                    title: (context) => {
                        const index = context[0].dataIndex;
                        const date = new Date(this.currentWeekStart);
                        date.setDate(date.getDate() + index);
                        return `${context[0].label} (${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')})`;
                    }
                }
            }
        }
    };

    this.charts.weekly = new Chart(ctxWeek, {
        type: 'bar',
        data: {
            labels: weekDays,
            datasets: allDataForBars.map(d => ({ label: d.name, data: d.weekly, backgroundColor: d.color, stack: '0' }))
        },
        options: weeklyOptions
    });

    // --- VẼ BIỂU ĐỒ THÁNG ---
    const ctxMonth = document.getElementById('monthlyChart').getContext('2d');
    if (this.charts.monthly) this.charts.monthly.destroy();

    const monthlyOptions = {
        ...commonOptions,
        plugins: {
            ...commonOptions.plugins,
            tooltip: {
                ...commonOptions.plugins.tooltip,
                callbacks: {
                    ...commonOptions.plugins.tooltip.callbacks,
                    title: (context) => `${String(context[0].label).padStart(2, '0')}/${String(mMonth + 1).padStart(2, '0')}`
                }
            }
        }
    };

    this.charts.monthly = new Chart(ctxMonth, {
        type: 'bar',
        data: {
            labels: monthlyLabels,
            datasets: allDataForBars.map(d => ({ label: d.name, data: d.monthly, backgroundColor: d.color, stack: '0' }))
        },
        options: monthlyOptions
    });

   
    const ctxDensity = document.getElementById('reportDensityChart');
    if (ctxDensity) {
        // 1. Update the Title
        const densityTitle = document.getElementById('density-month-title');
        if (densityTitle) {
            densityTitle.innerText = `Month ${new Date(mYear, mMonth).toLocaleDateString('en-GB', { month: 'numeric', year: 'numeric' })}`;
        }

        // 2. Prepare Data (Calculate this BEFORE checking chart existence)
        const daysInMonth = monthlyLabels.length;
        const dailyMinutes = new Array(daysInMonth).fill(0);
        const dailyCounts = new Array(daysInMonth).fill(0);
        const dailyAwareCounts = new Array(daysInMonth).fill(0); // MỚI: Mảng chứa dữ liệu Tỉnh giác

        this.data.logs.forEach(log => {
            const goal = this.data.goals.find(g => g.id === log.goalId);
            if (!goal || goal.type !== 'meditation') return;

            const logDateObj = new Date(log.timestamp || log.date);
            if (logDateObj.getFullYear() !== mYear || logDateObj.getMonth() !== mMonth) return;

            const dayIdx = logDateObj.getDate() - 1;

            const minutes = log.minutes;
            const count = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);
            const awareCount = log.awarenessCount || 0; // MỚI: Lấy số liệu Tỉnh giác

            if (minutes > 0) {
                dailyMinutes[dayIdx] += minutes;
                dailyCounts[dayIdx] += count;
                dailyAwareCounts[dayIdx] += awareCount; // MỚI: Cộng dồn
            }
        });

        // Tính tỷ lệ Chánh niệm/phút
        const densityData = dailyMinutes.map((mins, i) => {
            return mins > 0 ? (dailyCounts[i] / mins).toFixed(1) : 0;
        });

        // MỚI: Tính tỷ lệ Tỉnh giác/phút
        const awareDensityData = dailyMinutes.map((mins, i) => {
            return mins > 0 ? (dailyAwareCounts[i] / mins).toFixed(1) : 0;
        });

        // 3. Logic: Update if exists, Create if new
        if (this.charts.reportDensity) {
            // SMOOTH UPDATE: Swap data and call update()
            this.charts.reportDensity.data.labels = monthlyLabels;
            this.charts.reportDensity.data.datasets[0].data = densityData;
            this.charts.reportDensity.data.datasets[1].data = awareDensityData; // Update dataset 2
            this.charts.reportDensity.update();
        } else {
            // INITIAL CREATE
            const ctxD = ctxDensity.getContext('2d');
            this.charts.reportDensity = new Chart(ctxD, {
                type: 'line',
                data: {
                    labels: monthlyLabels,
                    datasets: [
                        {
                            label: 'Mindfulness/min',
                            data: densityData,
                            borderColor: '#34d399', // Màu xanh (Emerald) cho Chánh niệm
                            backgroundColor: 'rgba(52, 211, 153, 0.1)',
                            borderWidth: 1.5,
                            fill: true,
                            tension: 0.3,
                            yAxisID: 'y', // Gắn vào trục trái
                        },
                        {
                            label: 'Alertness/min', // Dataset MỚI
                            data: awareDensityData,
                            borderColor: '#818cf8',
                            backgroundColor: 'rgba(129, 140, 248, 0.1)',
                            borderWidth: 1.5,
                            fill: true,
                            tension: 0.3,
                            yAxisID: 'y', // Gắn vào trục phải
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: true
                    },
                    elements: {
                        point: {
                            hitRadius: 30,
                            hoverRadius: 3,
                            radius: 1.3,
                        }
                    },
                    plugins: {
                        legend: { 
                            display: true, // Hiển thị chú thích để phân biệt 2 đường
                            labels: { color: '#9ca3af', font: { size: 10 }, boxWidth: 10 }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const d = context[0].label;
                                    return `${String(d).padStart(2, '0')}/${String(mMonth + 1).padStart(2, '0')}`;
                                },
                                label: function(context) {
                                    // Hiển thị label tương ứng với dataset
                                    return ` ${context.dataset.label}: ${context.raw}`;
                                },
                                labelColor: function(context) {
                                    return {
                                        borderColor: context.dataset.borderColor,
                                        backgroundColor: context.dataset.borderColor,
                                        borderWidth: 0,
                                        borderRadius: 2,
                                    };
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#9ca3af', font: { size: 10 } },
                            grid: { color: 'rgba(55, 65, 81, 0.3)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            grid: { color: '#374151' },
                            ticks: { color: '#9ca3af', font: { size: 10 } },
                            title: { display: false } // Ẩn tên trục để tiết kiệm chỗ
                        },
                    
                    }
                }
            });
        }
    } }

changeReportWeek(dir) { this.currentWeekStart.setDate(this.currentWeekStart.getDate() + (dir * 7)); this.renderReports(); }
            changeReportMonth(dir) { this.currentMonth.setMonth(this.currentMonth.getMonth() + dir); this.renderReports(); }
            changeMonth(dir) { this.currentMonth.setMonth(this.currentMonth.getMonth() + dir); this.renderCalendar(); }

updateStats() {
    this.recalculateStreak();

    const totalMindfulness = this.data.logs.reduce((sum, log) => {

        return sum + (log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0));
    }, 0);

    this.data.xp = totalMindfulness; 

    document.getElementById('streak-disp').innerText = `${this.data.streak} 🔥`;
    document.getElementById('xp-disp').innerText = `${this.data.xp}`;

    
}
            
            recalculateStreak() {
                const activeDates = [...new Set(this.data.logs.filter(l => l.minutes > 0).map(l => l.date))].sort();
                if (activeDates.length === 0) { this.data.streak = 0; return; }
                let streak = 1;
                for (let i = activeDates.length - 2; i >= 0; i--) {
                    const prev = new Date(activeDates[i]);
                    const next = new Date(activeDates[i + 1]);
                    if ((next - prev) < (1000 * 60 * 60 * 48) && (next - prev) > 0) streak++; else break;
                }
                const now = new Date(this.today.getFullYear(), this.today.getMonth(), this.today.getDate());
                const last = new Date(activeDates[activeDates.length - 1]);
                if ((now - last) / (1000 * 60 * 60 * 24) > 1) this.data.streak = 0; else this.data.streak = streak;
            }

           checkAchievements(silent = false) {
    let newUnlock = false;
    const unlockedTitles = []; // Danh sách các huy hiệu vừa mở

    BADGES.forEach(badge => {
        // Bỏ qua các badge thủ công
        if (badge.id === 'explorer' || badge.id === 'safe_keeper') return;

        if (!this.data.achievements.includes(badge.id) && badge.condition(this.data)) {
            this.data.achievements.push(badge.id);
            unlockedTitles.push(badge.title);
            
            // Chỉ hiện toast nếu không bật chế độ im lặng
            if (!silent) {
                this.showToast(`💎 Unlocked Pāramī: ${badge.title}`, true);
            }
            newUnlock = true;
        }
    });

    if (newUnlock) this.save();
    this.renderAchievementsUI();
    
    return unlockedTitles; // Trả về danh sách để xử lý hiển thị sau
}

// 2. Manual trigger for "Explorer" and "Safe Keeper"
unlockBadge(id) {
    if (!this.data.achievements.includes(id)) {
        this.data.achievements.push(id);
        const badge = BADGES.find(b => b.id === id);
        this.showToast(`💎 Unlocked Pāramī: ${badge.title}`);
        this.save();
        this.renderAchievementsUI();
    }
}
renderAchievementsUI() {
    const container = document.getElementById('achievement-list');
    if (!container) return;
    container.innerHTML = '';

    // Default Locked Style (Gray)
    const LOCKED_COLOR = '#4b5563';

    BADGES.forEach(badge => {
        const isUnlocked = this.data.achievements.includes(badge.id);
        
        
        const badgeColor = isUnlocked ? badge.color : LOCKED_COLOR;
        
        // Dynamic Styles based on the specific badge color
        const bgColor = this.hexToRgba(badgeColor, 0.1);
        const borderColor = badgeColor;
        const iconColor = isUnlocked ? badge.color : '#6b7280';
        const textColor = isUnlocked ? '#f3f4f6' : '#9ca3af';

        const div = document.createElement('div');
        div.style.cssText = `
            display: flex; 
            align-items: center; 
            gap: 15px; 
            padding: 12px;
            background: ${isUnlocked ? bgColor : 'rgba(255,255,255,0.03)'};
            border: 1px solid ${isUnlocked ?  borderColor: 'var(--border)'};
            border-radius: 8px; 
            margin-bottom: 10px;
            transition: all 0.4s ease;
			opacity: ${isUnlocked ? '1' : '0.7'};
        `;

        div.innerHTML = `
            <div style="
                min-width: 42px; height: 42px; border-radius: 10px;
                display: flex; align-items: center; justify-content: center;
                border: 2px solid ${iconColor}; 
                color: ${iconColor}; 
                font-size: 18px;
                background: rgba(0,0,0,0.2);
                ${isUnlocked ? `box-shadow: 0 0 10px ${this.hexToRgba(badgeColor, 0.4)};` : ''}
            ">
                <i class="${badge.icon.includes('fab') ? badge.icon : 'fas ' + badge.icon}"></i>
            </div>
            <div style="flex: 1;">
                <div style="font-weight: 600; color: ${textColor}; font-size: 14px; display: flex; justify-content: space-between;">
                    ${badge.title}
                    <span style="font-size: 10px; color: ${iconColor}; text-transform: uppercase; letter-spacing: 1px; font-weight:bold;">
                        ${isUnlocked ? 'Achieved' : ''}
                    </span>
                </div>
                <div style="font-size: 11px; color: #9ca3af; margin-top: 2px;">
                    ${badge.desc}
                </div>
            </div>
        `;
        container.appendChild(div);
    });
}

openBadgePicker() {
    this.lastSelectedBadgeTitle = null;
    if (document.getElementById('badge-picker-modal')) {
        document.getElementById('badge-picker-modal').remove();
    }

    const modalHtml = `
        <div id="badge-picker-modal" class="modal" style="display:flex; z-index: 3000; align-items: center; justify-content: center;">
            <div class="modal-content" style="max-width: 550px; width: 95%; max-height: 85vh; display: flex; flex-direction: column; padding: 0; border-radius: 16px;">
                
                <div style="padding: 15px 20px; border-bottom: 1px solid var(--border); position: relative; display: flex; justify-content: center; align-items: center; background: var(--surface); border-radius: 16px 16px 0 0;">
                    <h3 style="margin: 0; font-size: 18px;"><i class="fas fa-award"></i> Choose Pāramī</h3>
                    <button class="btn-icon" onclick="app.closeBadgePicker()" style="position: absolute; right: 20px; color: var(--text-light); background: transparent;"><i class="fas fa-times"></i></button>
                </div>

                <div style="padding: 20px; overflow-y: auto; background: var(--bg);">
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 12px;">
                        ${BADGES.map(badge => {
                            // --- MODIFICATION: ALWAYS UNLOCKED FOR PICKER ---
                            const isUnlocked = this.data.achievements.includes(badge.id);
                            const isActive = this.data.activeBadge === badge.id;
                            
                            // Color Logic
                            const badgeColor = isUnlocked ? (badge.color || '#cd7f32') : '#4b5563';
                            let opacity = isUnlocked ? '1' : '0.4';
                            let cursor = isUnlocked ? 'pointer' : 'not-allowed';
                            
                            // Active State
                            let bg = isActive ? this.hexToRgba(badgeColor, 0.15) : 'rgba(255, 255, 255, 0.03)';
                            let border = isActive ? `2px solid ${badgeColor}` : '1px solid var(--border)';
                            let transformHover = 'translateY(-2px)';
                            
                            const checkMarkDisplay = isActive ? 'block' : 'none';

                            return `
                                <div id="badge-option-${badge.id}"
                                     class="badge-option-item"
                                     onclick="app.selectBadge('${badge.id}')" 
                                     style="
                                        position: relative;
                                        display: flex; flex-direction: column; align-items: center; justify-content: center;
                                        padding: 15px 5px;
                                        background: ${bg};
                                        border: ${border};
                                        border-radius: 12px;
                                        opacity: ${opacity};
                                        cursor: ${cursor};
                                        transition: all 0.2s ease;
                                        text-align: center;
                                        min-height: 90px;
                                     "
                                     onmouseover="this.style.transform='${transformHover}'"
                                     onmouseout="this.style.transform='translateY(0)'"
                                     title="${badge.title} - ${badge.desc}"
                                >
                                    <div id="check-${badge.id}" style="display: ${checkMarkDisplay}; position:absolute; top:5px; right:5px; color:${badgeColor}; font-size:12px;">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                    <div style="font-size: 24px; color: ${badgeColor}; margin-bottom: 8px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">
                                    <i class="${badge.icon.includes('fab') ? badge.icon : 'fas ' + badge.icon}"></i>
                                    </div>
                                    <div style="font-size: 11px; font-weight: 600; color: var(--text); line-height: 1.3;">${badge.title}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>

                <div style="padding: 15px 20px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; background: var(--surface); border-radius: 0 0 16px 16px;">
                    <button class="btn" onclick="app.closeBadgePicker()">Save & Close</button>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}
selectBadge(badgeId) {
    // 1. Update Data & Save
    this.data.activeBadge = badgeId;
    this.save();
    
    // 2. Update the main display header immediately
    this.loadActiveBadge(); 
    
    // 3. Update Modal Visuals (Highlighting the selected item)
    const badge = BADGES.find(b => b.id === badgeId);
    this.lastSelectedBadgeTitle = badge.title;

    // Reset all options in the modal
    const allOptions = document.querySelectorAll('.badge-option-item');
    allOptions.forEach(el => {
        el.style.borderColor = 'var(--border)';
        el.style.borderWidth = '1px';
        el.style.background = 'rgba(255, 255, 255, 0.03)';
        const check = el.querySelector('div[id^="check-"]');
        if(check) check.style.display = 'none';
    });

    // Highlight the clicked option
    const activeEl = document.getElementById(`badge-option-${badgeId}`);
    if (activeEl) {
        const color = badge.color || '#cd7f32';
        activeEl.style.borderColor = color;
        activeEl.style.borderWidth = '2px';
        activeEl.style.background = this.hexToRgba(color, 0.15);
        const activeCheck = document.getElementById(`check-${badgeId}`);
        if(activeCheck) activeCheck.style.display = 'block';
    }
}

closeBadgePicker() {
    const modal = document.getElementById('badge-picker-modal');
    if (modal) {
        modal.remove();
        
        // Only show toast if a badge was actually picked during this session
        if (this.lastSelectedBadgeTitle) {
            this.showToast(`Active Pāramī set to: ${this.lastSelectedBadgeTitle}`);
            this.lastSelectedBadgeTitle = null; // Reset
        }
    }
}

// Update your refreshUI or init logic to load the saved badge
// FIND THIS FUNCTION IN nh.js
loadActiveBadge() {
    const container = document.getElementById('current-active-badge');
    if (!container) return;

    if (this.data.activeBadge) {
        const badge = BADGES.find(b => b.id === this.data.activeBadge);
        if (badge) {
            // Get color or fallback
            const color = badge.color || '#cd7f32'; 

            // Render Icon
            container.innerHTML = `<i class="${badge.icon.includes('fab') ? badge.icon : 'fas ' + badge.icon}"></i>`;
            
            // --- UPDATED STYLING FOR GLOW EFFECT ---
            
            // 1. Keep the Icon White (Max brightness)
            container.style.color = '#fcfcfc'; 
            
            // 2. Add a text-shadow so the white icon glows with the badge color
            container.style.textShadow = `0 0 5px ${color}`;

            // 3. Keep the colored border
            container.style.borderColor = color;

            // 4. Increase background opacity slightly for richness
            container.style.backgroundColor = this.hexToRgba(color, 0.2); 
            
            // 5. Increase box-shadow radius back to 15px (matching default) or higher
            container.style.boxShadow = `0 0 15px ${this.hexToRgba(color, 0.6)}`;
            
            // ---------------------------------------
            
            // Remove old static class if it exists
            container.classList.remove('silver');
        }
    } else {
        // Default state (No badge selected) - Keep as is
        container.innerHTML = `<i class="fas fa-award"></i>`;
        
        // Explicitly set default styles to match CSS .badge-display
        container.style.color = '#ffffff';
        container.style.textShadow = 'none'; // Reset text shadow
        container.style.borderColor = '#c0c0c0'; // Silver border
        container.style.backgroundColor = 'rgba(192, 192, 192, 0.2)';
        container.style.boxShadow = '0 0 15px rgba(192, 192, 192, 0.4)';
    }
}

            formatTime(seconds) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = seconds % 60;
                return `${h > 0 ? h+':' : ''}${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            }
            toIsoDate(date) {
    const y = date.getFullYear();

    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');
    return `${y}-${m}-${d}`;
}
            toDateTimeInput(timestamp) {
    const date = new Date(timestamp);
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');
    const hh = String(date.getHours()).padStart(2, '0');
    const mm = String(date.getMinutes()).padStart(2, '0');
    return `${y}-${m}-${d}T${hh}:${mm}`;
}
            toDisplayDate(timestamp) { const d = new Date(timestamp); return `${d.getDate().toString().padStart(2, '0')}/${(d.getMonth() + 1).toString().padStart(2, '0')} ${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}`; }
            showToast(msg, isAchievement = false) {
                const t = document.getElementById('toast');
                document.getElementById('toast-msg').innerText = msg;
                t.classList.remove('achievement'); if (isAchievement) t.classList.add('achievement');
                t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 3000);
            }
            
            switchView(viewName) {
                document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
                document.getElementById(`view-${viewName}`).classList.add('active');
                document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
                event.currentTarget.classList.add('active');
                
                const titles = {
                    'dashboard': 'Journal',
                    'calendar': 'Calendar',
                    'reports': 'Statistics',
					'analytics': 'Analytics',
					'pro': 'Advanced',
					'achievements': 'Pāramī'
                };
                
                document.getElementById('page-title').innerText = titles[viewName] || 'Journal';
                if (viewName === 'reports') { this.renderReports(); }
                if (viewName === 'calendar') this.renderCalendar();
				if (viewName === 'analytics') this.renderAnalytics();
				if (viewName === 'pro') this.renderProAnalytics(); // <-- Add this line
            }
            
            exportData() {

        const dataStr = JSON.stringify(this.data); 
        const modal = document.getElementById('backup-modal');
        
        modal.style.display = 'flex';
    }

    closeBackupModal() {
        document.getElementById('backup-modal').style.display = 'none';
    }

    shareBackup() {
    const dataStr = JSON.stringify(this.data);
    const now = new Date();
    const datePart = now.toISOString().split('T')[0];
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const fileName = `backup_${datePart}-${hours}h${minutes}.txt`;

    if (typeof Website2APK !== 'undefined' && Website2APK.shareIntent) {
        Website2APK.shareIntent(dataStr, "Backup", "");
        return;
    }

    if (navigator.share) {
        const file = new File([dataStr], fileName, { type: "application/json" });
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
            navigator.share({
                files: [file],
                title: 'Meditator Journal Backup',
                text: 'Backup data file.'
            })
            .then(() => this.showToast('Shared successfully!'))
            .catch((error) => {

                if (error.name !== 'AbortError') this.copyToClipboard(dataStr);
            });
            return;
        } 
    } 

    this.copyToClipboard(dataStr);
}
showInteractionInfo() {
    const msg = "• MINDFULNESS: Maintaining awareness of the chosen object and noting each occurrence. E.g., one tap per breath cycle.\n\n" +
                "• ALERTNESS: Recognizing the state of mind, detecting distractions (mind-wandering) & returning to the object.\n Mindfulness time for a single moment of alertness = hold duration";
    alert(msg);
}
copyToClipboard(text) {

    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
            this.showToast('Data copied to clipboard!');
        }).catch(err => {
            this.fallbackCopyText(text);
        });
    } else {
        this.fallbackCopyText(text);
    }
}

fallbackCopyText(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed"; 
    textArea.style.left = "-9999px";
    textArea.style.top = "0";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
        const successful = document.execCommand('copy');
        if (successful) {
            this.showToast('Backup data copied!');
        } else {
            this.showToast('Copy failed. Please use the Backup button to download the file.');
        }
    } catch (err) {
        this.showToast('Error copying data.');
    }
    document.body.removeChild(textArea);
}

   downloadFile() {
    const dataStr = JSON.stringify(this.data);
    const now = new Date();
    const datePart = now.toISOString().split('T')[0];
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const fileName = `backup_${datePart}-${hours}h${minutes}.txt`;

    if (typeof Website2APK !== 'undefined') {

        if (Website2APK.saveBackup) {

            const base64 = btoa(unescape(encodeURIComponent(dataStr)));

            Website2APK.saveBackup(base64, fileName);
            this.showToast('Saving file to Download...');
        } 
    } else {

        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
        this.showToast('File downloaded successfully!');
    }
}

    handleFileUpload(inputElement) {
        const file = inputElement.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {

            this.processRestoreData(e.target.result);
        };
        reader.readAsText(file);

        inputElement.value = '';
    }

    async processRestoreData(jsonString) {
        try {
            const json = JSON.parse(jsonString);

            if (!json.goals || !Array.isArray(json.goals) || !json.logs) {
                throw new Error("Invalid file structure (Missing goals/logs).");
            }

            if (confirm(`Found ${json.goals.length} goals and ${json.logs.length} logs.\nAre you sure you want to overwrite current data?`)) {
                // Save to IndexedDB
                await dbHelper.saveAll(json);
                alert("Restore success. The app will reload.");
                location.reload(); 
            }
        } catch (err) {
            alert("Restore error: " + err.message);
        }
    }
            resetApp() {
    if (confirm('Delete ALL data & associated history? This action cannot be undone.')) {
        // 1. QUAN TRỌNG: Đóng kết nối DB đang mở
        // Nếu không đóng, trình duyệt sẽ chặn (block) lệnh xóa và chờ mãi mãi.
        if (dbHelper.db) {
            dbHelper.db.close();
        }

        // 2. Xóa dữ liệu LocalStorage (Legacy & Config)
        localStorage.removeItem('chronoData');
        localStorage.removeItem('chronoData_backup');
        localStorage.removeItem('anaGoalFilter');
        localStorage.removeItem('intro_seen'); // Tùy chọn: Xóa cái này để hiện lại intro

        // 3. Gửi yêu cầu xóa IndexedDB
        const req = indexedDB.deleteDatabase(DB_CONFIG.name);

        // Xử lý khi thành công
        req.onsuccess = () => {
            console.log("DB Deleted successfully");
            location.reload();
        };

        // Xử lý khi bị lỗi
        req.onerror = () => {
            console.error("Could not delete DB");
            location.reload(); // Vẫn reload để đảm bảo UI được làm mới
        };

        // Xử lý khi bị chặn (Blocked) - Đây là trường hợp dự phòng
        req.onblocked = () => {
            console.warn("DB Delete blocked - forcing reload");
            location.reload();
        };
    }
}
			deleteSession() {
    const logId = document.getElementById('s-log-id').value;
    const goalId = document.getElementById('s-goal-id').value;

    if (!logId) return; 

    if (confirm('Permanently delete this session from history?')) {

        const logIndex = this.data.logs.findIndex(l => l.timestamp == logId);
        if (logIndex === -1) return;
        
        const log = this.data.logs[logIndex];
        const goal = this.data.goals.find(g => g.id === goalId);

        if (goal) {
            goal.totalMinutes -= log.minutes;
            if (goal.totalMinutes < 0) goal.totalMinutes = 0;

            if (goal.type === 'meditation') {
                const count = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);
                goal.totalMindfulness -= count;
                if (goal.totalMindfulness < 0) goal.totalMindfulness = 0;
            }
        }

        this.data.logs.splice(logIndex, 1);
dbHelper.deleteLog(parseInt(logId)).then(() => {
            this.showToast('Session deleted!');
        }).catch(err => console.error(err));
        
        this.save();
        this.save();
        this.renderGoals();      
        this.renderCalendar();   
        this.renderReports();    
        this.updateStats();      
        
        this.closeSessionModal();
        this.showToast('Session deleted!');
    }
}
            openSessionModal(goalId, minutes = 0, logId = null, startTime = Date.now()) {
    document.getElementById('session-modal').style.display = 'flex';
    document.getElementById('s-goal-id').value = goalId;
    document.getElementById('s-log-id').value = logId || '';
    document.getElementById('s-date').value = this.toDateTimeInput(startTime);
    document.getElementById('s-minutes').value = minutes;

    const deleteBtn = document.getElementById('btn-delete-session');
    if (logId) deleteBtn.style.display = 'block'; 
    else deleteBtn.style.display = 'none';  
    
    const goal = this.data.goals.find(g => g.id === goalId);
    const mindGroup = document.getElementById('s-mindfulness-group');
    const mindInput = document.getElementById('s-mindfulness');
    const thresholdInput = document.getElementById('s-threshold');
    
    if (goal && goal.type === 'meditation') {
        mindGroup.style.display = 'block';
        let currentCount = 0;
        let currentThreshold = 6; 

        if (logId) {
            const log = this.data.logs.find(l => l.timestamp == logId);
            if (log) {
                currentCount = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);

                if(log.threshold) currentThreshold = log.threshold;
            }
        }
        mindInput.value = currentCount;
        thresholdInput.value = currentThreshold;
    } else {
        mindGroup.style.display = 'none';
        mindInput.value = 0;
    }

    let notes = ''; 
    if(logId) { 
        const log = this.data.logs.find(l => l.timestamp == logId); 
        if(log && log.notes) notes = log.notes; 
    }
    document.getElementById('s-notes').value = notes;
	this.renderQuickTags('session-tags', 's-notes');
    document.getElementById('session-title').innerText = logId ? 'Update log' : 'Add log';
}
            closeSessionModal() { document.getElementById('session-modal').style.display = 'none'; }
           logSessionConfirm(e) {
    e.preventDefault();
    const goalId = document.getElementById('s-goal-id').value;
    const logId = document.getElementById('s-log-id').value;
    const dateTimeStr = document.getElementById('s-date').value;
    const minutes = parseInt(document.getElementById('s-minutes').value);
    
    const mindfulness = parseInt(document.getElementById('s-mindfulness').value) || 0;
    const threshold = parseInt(document.getElementById('s-threshold').value) || 10; 
    let notes = document.getElementById('s-notes').value;
    
    if (minutes <= 0) return;
    
    const goal = this.data.goals.find(g => g.id === goalId);
    
    if (goal && goal.type === 'meditation') {
        let cleanNotes = notes.replace(/^Mindfulness: \d+(\.\s*)?/, '').trim();
        if (mindfulness > 0) {
            notes = `Mindfulness: ${mindfulness}. ${cleanNotes}`;
        } else {
            notes = cleanNotes;
        }

        goal.lastThreshold = threshold;
    }

    const dateObj = new Date(dateTimeStr);
    const timestamp = dateObj.getTime();
    const dateKey = dateTimeStr.split('T')[0]; 
    
    if (logId) {
        const log = this.data.logs.find(l => l.timestamp == logId);
        if (log) {
            const oldMinutes = log.minutes;
            const oldMindfulness = log.count !== undefined ? log.count : (log.touches ? log.touches.length : 0);
                    
                if (Number(logId) !== timestamp) {
                    dbHelper.deleteLog(logId);
                }
            log.minutes = minutes; 
            log.date = dateKey; 
            log.timestamp = timestamp; 
            log.notes = notes; 
            log.count = mindfulness;
            log.threshold = threshold; 
            
            if (goal) {
                goal.totalMinutes += (minutes - oldMinutes);
                if (goal.type === 'meditation') {
                    if (!goal.totalMindfulness) goal.totalMindfulness = 0;
                    goal.totalMindfulness = goal.totalMindfulness - oldMindfulness + mindfulness;
                }
            }
        }
    } else {
        this.data.logs.push({ 
            goalId, 
            date: dateKey, 
            timestamp, 
            minutes, 
            notes, 
            count: mindfulness, 
            touches: [],
            threshold: threshold 
        });
        
        if (goal) {
            goal.totalMinutes += minutes;
            if (goal.type === 'meditation') {
                if (!goal.totalMindfulness) goal.totalMindfulness = 0;
                goal.totalMindfulness += mindfulness;
            }
        }
    }
    
    this.save(); 
    this.renderGoals(); 
    this.renderCalendar(); 
    this.renderReports(); 
    const newBadges = this.checkAchievements(true);
    this.closeSessionModal(); 
    this.showToast(logId ? 'Session Updated!' : 'Session Logged!');
	if (newBadges.length > 0) {
        setTimeout(() => {
            newBadges.forEach((title, index) => {
                setTimeout(() => {
                    this.showToast(`💎 Unlocked Pāramī: ${title}`, true);
                }, index * 3500);
            });
        }, 1000);
    }
}
                      deleteGoal(id) {
    if(confirm('Delete this goal and ALL associated history? This action cannot be undone.')) {
        
        this.data.goals = this.data.goals.filter(g => g.id !== id);
        this.data.logs = this.data.logs.filter(log => log.goalId !== id);
        
        this.updateStats(); 

        dbHelper.deleteGoalData(id)
            .then(() => {
                
                dbHelper.saveAll({
                    goals: this.data.goals,
                    logs: [], 
                    xp: this.data.xp,
                    streak: this.data.streak,
                    achievements: this.data.achievements,
                    medSettings: this.data.medSettings
                }).catch(e => console.log("Meta save update")); 

                // 3. Update UI
                this.renderGoals(); 
                this.renderReports(); 
                this.renderCalendar(); 
                
                this.showToast('Goal and history deleted!');
            })
            .catch(err => {
                console.error(err);
                this.showToast('Error!');
            });
    }
}
            renderDate() {
                 document.getElementById('current-date').innerText = new Date().toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            }
        }

        const app = new GoalTracker();